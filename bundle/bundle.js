/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Parser = {\n  running: false,\n  config: void 0,\n  minConfig: __webpack_require__(/*! ./config/minimum */ \"./config/minimum.json\"),\n  MAX_STAGE: 11,\n  getConfig() {\n    return { ...this.minConfig, ...this.config };\n  },\n  run(callback) {\n    const { running } = this;\n    this.running = true;\n    try {\n      const result = callback();\n      this.running = running;\n      return result;\n    } catch (e) {\n      this.running = running;\n      throw e;\n    }\n  },\n  normalizeTitle(title, defaultNs = 0, config = Parser.getConfig(), halfParsed = false) {\n    let token;\n    if (!halfParsed) {\n      const Token = __webpack_require__(/*! ./src */ \"./src/index.js\");\n      token = this.run(() => {\n        const newToken = new Token(String(title), config), parseOnce = newToken.getAttribute(\"parseOnce\");\n        parseOnce();\n        return parseOnce();\n      });\n      title = token.firstChild;\n    }\n    const Title = __webpack_require__(/*! ./lib/title */ \"./lib/title.js\");\n    return new Title(String(title), defaultNs, config);\n  },\n  parse(wikitext, include, maxStage = Parser.MAX_STAGE, config = Parser.getConfig()) {\n    const Token = __webpack_require__(/*! ./src */ \"./src/index.js\");\n    let token;\n    this.run(() => {\n      if (typeof wikitext === \"string\") {\n        token = new Token(wikitext, config);\n      } else if (wikitext instanceof Token) {\n        token = wikitext;\n        wikitext = String(token);\n      }\n      token.parse(maxStage, include);\n    });\n    return token;\n  },\n  print(wikitext, include = false, config = Parser.getConfig()) {\n    const token = this.parse(wikitext, include, this.MAX_STAGE, config);\n    return `<div class=\"wikiparser\">${token.print()} </div>`;\n  }\n};\nconst def = {};\nfor (const key in Parser) {\n  if ([\"MAX_STAGE\", \"minConfig\"].includes(key)) {\n    def[key] = { enumerable: false, writable: false };\n  } else if (![\"config\", \"normalizeTitle\", \"parse\", \"print\"].includes(key)) {\n    def[key] = { enumerable: false };\n  }\n}\nObject.defineProperties(Parser, def);\nwindow.Parser = Parser;\nmodule.exports = Parser;\n\n\n//# sourceURL=webpack://wikiparser-node/./index.js?");

/***/ }),

/***/ "./lib/element.js":
/*!************************!*\
  !*** ./lib/element.js ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst { print } = __webpack_require__(/*! ../util/string */ \"./util/string.js\"), AstNode = __webpack_require__(/*! ./node */ \"./lib/node.js\"), AstText = __webpack_require__(/*! ./text */ \"./lib/text.js\");\nconst _AstElement = class extends AstNode {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"name\");\n  }\n  get length() {\n    return this.childNodes.length;\n  }\n  get children() {\n    const children = this.childNodes.filter(({ type }) => type !== \"text\");\n    return children;\n  }\n  get firstElementChild() {\n    return this.childNodes.find(({ type }) => type !== \"text\");\n  }\n  get lastElementChild() {\n    return this.children.at(-1);\n  }\n  append(...elements) {\n    for (const element of elements) {\n      this.insertAt(element);\n    }\n  }\n  replaceChildren(...elements) {\n    for (let i = this.childNodes.length - 1; i >= 0; i--) {\n      this.removeAt(i);\n    }\n    this.append(...elements);\n  }\n  setText(str, i = 0) {\n    const oldText = this.childNodes.at(i), { data } = oldText;\n    oldText.replaceData(str);\n    return data;\n  }\n  toString(separator = \"\") {\n    return this.childNodes.map((child) => child.toString()).join(separator);\n  }\n  lint(start = 0) {\n    const SyntaxToken = __webpack_require__(/*! ../src/syntax */ \"./src/syntax.js\");\n    if (this instanceof SyntaxToken || this.constructor.hidden || this.type === \"ext-inner\" && _AstElement.lintIgnoredExt.has(this.name)) {\n      return [];\n    }\n    const errors = [];\n    for (let i = 0, cur = start + this.getPadding(); i < this.childNodes.length; i++) {\n      const child = this.childNodes[i];\n      errors.push(...child.lint(cur));\n      cur += String(child).length + this.getGaps(i);\n    }\n    return errors;\n  }\n  print(opt = {}) {\n    var _a;\n    return String(this) ? `<span class=\"wpb-${(_a = opt.class) != null ? _a : this.type}\">${print(this.childNodes, opt)}</span>` : \"\";\n  }\n};\nlet AstElement = _AstElement;\n__publicField(AstElement, \"lintIgnoredExt\", /* @__PURE__ */ new Set([\n  \"nowiki\",\n  \"pre\",\n  \"charinsert\",\n  \"score\",\n  \"syntaxhighlight\",\n  \"source\",\n  \"math\",\n  \"chem\",\n  \"ce\",\n  \"graph\",\n  \"mapframe\",\n  \"maplink\",\n  \"quiz\",\n  \"templatedata\",\n  \"timeline\"\n]));\nmodule.exports = AstElement;\n\n\n//# sourceURL=webpack://wikiparser-node/./lib/element.js?");

/***/ }),

/***/ "./lib/node.js":
/*!*********************!*\
  !*** ./lib/node.js ***!
  \*********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\nvar _parentNode, _getDimension, getDimension_fn, _getPosition, getPosition_fn;\nclass AstNode {\n  constructor() {\n    __privateAdd(this, _getDimension);\n    __privateAdd(this, _getPosition);\n    __publicField(this, \"type\");\n    __publicField(this, \"childNodes\", []);\n    __privateAdd(this, _parentNode, void 0);\n  }\n  get firstChild() {\n    return this.childNodes[0];\n  }\n  get lastChild() {\n    return this.childNodes.at(-1);\n  }\n  get parentNode() {\n    return __privateGet(this, _parentNode);\n  }\n  get nextSibling() {\n    var _a;\n    const childNodes = (_a = __privateGet(this, _parentNode)) == null ? void 0 : _a.childNodes;\n    return childNodes && childNodes[childNodes.indexOf(this) + 1];\n  }\n  get previousSibling() {\n    var _a;\n    const childNodes = (_a = __privateGet(this, _parentNode)) == null ? void 0 : _a.childNodes;\n    return childNodes && childNodes[childNodes.indexOf(this) - 1];\n  }\n  hasAttribute(key) {\n    return key in this;\n  }\n  getAttribute(key) {\n    return this.hasAttribute(key) ? String(this[key]) : void 0;\n  }\n  setAttribute(key, value) {\n    if (key === \"parentNode\") {\n      __privateSet(this, _parentNode, value);\n    } else {\n      this[key] = value;\n    }\n    return this;\n  }\n  removeAt(i) {\n    const childNodes = [...this.childNodes], [node] = childNodes.splice(i, 1);\n    node.setAttribute(\"parentNode\");\n    this.setAttribute(\"childNodes\", childNodes);\n    return node;\n  }\n  insertAt(node, i = this.childNodes.length) {\n    const childNodes = [...this.childNodes];\n    node.setAttribute(\"parentNode\", this);\n    childNodes.splice(i, 0, node);\n    this.setAttribute(\"childNodes\", childNodes);\n    return node;\n  }\n  normalize() {\n    var _a;\n    const AstText = __webpack_require__(/*! ./text */ \"./lib/text.js\");\n    const childNodes = [...this.childNodes];\n    for (let i = childNodes.length - 1; i >= 0; i--) {\n      const { type, data } = childNodes[i];\n      if (this.getGaps(i - 1)) {\n      } else if (data === \"\") {\n        childNodes.splice(i, 1);\n      } else if (type === \"text\" && ((_a = childNodes[i - 1]) == null ? void 0 : _a.type) === \"text\") {\n        childNodes[i - 1].setAttribute(\"data\", childNodes[i - 1].data + data);\n        childNodes.splice(i, 1);\n      }\n    }\n    this.setAttribute(\"childNodes\", childNodes);\n  }\n  getRootNode() {\n    let { parentNode } = this;\n    while (parentNode == null ? void 0 : parentNode.parentNode) {\n      ({ parentNode } = parentNode);\n    }\n    return parentNode != null ? parentNode : this;\n  }\n  posFromIndex(index) {\n    const str = String(this);\n    if (index >= -str.length && index <= str.length && Number.isInteger(index)) {\n      const lines = str.slice(0, index).split(\"\\n\");\n      return { top: lines.length - 1, left: lines.at(-1).length };\n    }\n    return void 0;\n  }\n  getPadding() {\n    return 0;\n  }\n  getGaps() {\n    return 0;\n  }\n  getRelativeIndex(j) {\n    let childNodes;\n    const getIndex = (end, parent) => childNodes.slice(0, end).reduce(\n      (acc, cur, i) => acc + String(cur).length + parent.getGaps(i),\n      0\n    ) + parent.getPadding();\n    if (j === void 0) {\n      const { parentNode } = this;\n      if (parentNode) {\n        ({ childNodes } = parentNode);\n        return getIndex(childNodes.indexOf(this), parentNode);\n      }\n      return 0;\n    }\n    ({ childNodes } = this);\n    return getIndex(j, this);\n  }\n  getAbsoluteIndex() {\n    const { parentNode } = this;\n    return parentNode ? parentNode.getAbsoluteIndex() + this.getRelativeIndex() : 0;\n  }\n  getBoundingClientRect() {\n    return { ...__privateMethod(this, _getDimension, getDimension_fn).call(this), ...this.getRootNode().posFromIndex(this.getAbsoluteIndex()) };\n  }\n  get offsetHeight() {\n    return __privateMethod(this, _getDimension, getDimension_fn).call(this).height;\n  }\n  get offsetWidth() {\n    return __privateMethod(this, _getDimension, getDimension_fn).call(this).width;\n  }\n  get style() {\n    return { ...__privateMethod(this, _getPosition, getPosition_fn).call(this), ...__privateMethod(this, _getDimension, getDimension_fn).call(this), padding: this.getPadding() };\n  }\n}\n_parentNode = new WeakMap();\n_getDimension = new WeakSet();\ngetDimension_fn = function() {\n  const lines = String(this).split(\"\\n\");\n  return { height: lines.length, width: lines.at(-1).length };\n};\n_getPosition = new WeakSet();\ngetPosition_fn = function(j) {\n  var _a, _b;\n  return j === void 0 ? (_b = (_a = this.parentNode) == null ? void 0 : _a.posFromIndex(this.getRelativeIndex())) != null ? _b : { top: 0, left: 0 } : this.posFromIndex(this.getRelativeIndex(j));\n};\nmodule.exports = AstNode;\n\n\n//# sourceURL=webpack://wikiparser-node/./lib/node.js?");

/***/ }),

/***/ "./lib/text.js":
/*!*********************!*\
  !*** ./lib/text.js ***!
  \*********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\nvar _setData, setData_fn;\nconst AstNode = __webpack_require__(/*! ./node */ \"./lib/node.js\");\nconst _AstText = class extends AstNode {\n  constructor(text = \"\") {\n    super();\n    __privateAdd(this, _setData);\n    __publicField(this, \"type\", \"text\");\n    __publicField(this, \"data\");\n    this.data = text;\n  }\n  toString() {\n    return this.data;\n  }\n  replaceData(text = \"\") {\n    __privateMethod(this, _setData, setData_fn).call(this, text);\n  }\n  lint(start = 0) {\n    const { data } = this, errors = [...data.matchAll(_AstText.errorSyntax)];\n    if (errors.length > 0) {\n      const { top, left } = this.getRootNode().posFromIndex(start);\n      return errors.map(({ 0: error, 1: prefix, index }) => {\n        if (prefix) {\n          index += prefix.length;\n          error = error.slice(prefix.length);\n        }\n        const lines = data.slice(0, index).split(\"\\n\"), startLine = lines.length + top - 1, { length } = lines.at(-1), startCol = lines.length > 1 ? length : left + length;\n        return {\n          message: `\\u5B64\\u7ACB\\u7684\"${error[0]}\"`,\n          severity: error[0] === \"{\" || error[0] === \"}\" ? \"error\" : \"warning\",\n          startLine,\n          endLine: startLine,\n          startCol,\n          endCol: startCol + error.length\n        };\n      });\n    }\n    return [];\n  }\n};\nlet AstText = _AstText;\n_setData = new WeakSet();\nsetData_fn = function(text) {\n  return this.setAttribute(\"data\", String(text));\n};\n__publicField(AstText, \"errorSyntax\", /[{}]+|\\[{2,}|\\[(?!(?:(?!https?\\b)[^[])*\\])|((?:^|\\])[^[]*?)\\]+|<(?=\\s*\\/?\\w+[\\s/>])/giu);\nmodule.exports = AstText;\n\n\n//# sourceURL=webpack://wikiparser-node/./lib/text.js?");

/***/ }),

/***/ "./lib/title.js":
/*!**********************!*\
  !*** ./lib/title.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst Parser = __webpack_require__(/*! .. */ \"./index.js\");\nclass Title {\n  constructor(title, defaultNs = 0, config = Parser.getConfig()) {\n    __publicField(this, \"ns\", 0);\n    __publicField(this, \"valid\", true);\n    const { namespaces, nsid } = config;\n    let namespace = namespaces[defaultNs];\n    title = title.replaceAll(\"_\", \" \").trim();\n    if (title[0] === \":\") {\n      namespace = \"\";\n      title = title.slice(1).trim();\n    }\n    const m = title.split(\":\");\n    if (m.length > 1) {\n      const id = namespaces[nsid[m[0].trim().toLowerCase()]];\n      if (id !== void 0) {\n        namespace = id;\n        title = m.slice(1).join(\":\").trim();\n      }\n    }\n    this.ns = nsid[namespace.toLowerCase()];\n    const i = title.indexOf(\"#\");\n    let fragment;\n    if (i !== -1) {\n      fragment = title.slice(i + 1).trimEnd();\n      title = title.slice(0, i).trim();\n    }\n    this.valid = Boolean(title || fragment) && !/\\0\\d+[eh!+-]\\x7F|[<>[\\]{}|]/u.test(title);\n  }\n}\nmodule.exports = Title;\n\n\n//# sourceURL=webpack://wikiparser-node/./lib/title.js?");

/***/ }),

/***/ "./mixin/hidden.js":
/*!*************************!*\
  !*** ./mixin/hidden.js ***!
  \*************************/
/***/ ((module) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst hidden = (Constructor) => {\n  var _a;\n  return _a = class extends Constructor {\n  }, __publicField(_a, \"hidden\", true), _a;\n};\nmodule.exports = hidden;\n\n\n//# sourceURL=webpack://wikiparser-node/./mixin/hidden.js?");

/***/ }),

/***/ "./parser/brackets.js":
/*!****************************!*\
  !*** ./parser/brackets.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { removeComment } = __webpack_require__(/*! ../util/string */ \"./util/string.js\"), Parser = __webpack_require__(/*! .. */ \"./index.js\");\nconst parseBrackets = (text, config = Parser.getConfig(), accum = []) => {\n  var _a, _b, _c, _d, _e;\n  const source = \"^(\\0\\\\d+c\\x7F)*={1,6}|\\\\[\\\\[|\\\\{{2,}|-\\\\{(?!\\\\{)\", stack = [], closes = { \"=\": \"\\n\", \"{\": \"\\\\}{2,}|\\\\|\", \"-\": \"\\\\}-\", \"[\": \"\\\\]\\\\]\" }, marks = { \"!\": \"!\", \"!!\": \"+\", \"(!\": \"{\", \"!)\": \"}\", \"!-\": \"-\", \"=\": \"~\" };\n  let regex = new RegExp(source, \"gmu\"), mt = regex.exec(text), moreBraces = text.includes(\"}}\"), lastIndex;\n  while (mt || lastIndex <= text.length && ((_b = (_a = stack.at(-1)) == null ? void 0 : _a[0]) == null ? void 0 : _b[0]) === \"=\") {\n    if (mt == null ? void 0 : mt[1]) {\n      const [, { length }] = mt;\n      mt[0] = mt[0].slice(length);\n      mt.index += length;\n    }\n    const { 0: syntax, index: curIndex } = mt != null ? mt : { 0: \"\\n\", index: text.length }, top = (_c = stack.pop()) != null ? _c : {}, { 0: open, index, parts, findEqual: topFindEqual, pos: topPos } = top, innerEqual = syntax === \"=\" && topFindEqual;\n    if (syntax === \"]]\" || syntax === \"}-\") {\n      lastIndex = curIndex + 2;\n    } else if (syntax === \"\\n\") {\n      lastIndex = curIndex + 1;\n      const { pos, findEqual } = (_d = stack.at(-1)) != null ? _d : {};\n      if (!pos || findEqual || removeComment(text.slice(pos, index)) !== \"\") {\n        const rmt = /^(={1,6})(.+)\\1((?:\\s|\\0\\d+c\\x7F)*)$/u.exec(text.slice(index, curIndex));\n        if (rmt) {\n          text = `${text.slice(0, index)}\\0${accum.length}h\\x7F${text.slice(curIndex)}`;\n          lastIndex = index + 4 + String(accum.length).length;\n          const HeadingToken = __webpack_require__(/*! ../src/heading */ \"./src/heading.js\");\n          new HeadingToken(rmt[1].length, rmt.slice(2), config, accum);\n        }\n      }\n    } else if (syntax === \"|\" || innerEqual) {\n      lastIndex = curIndex + 1;\n      parts.at(-1).push(text.slice(topPos, curIndex));\n      if (syntax === \"|\") {\n        parts.push([]);\n      }\n      top.pos = lastIndex;\n      top.findEqual = syntax === \"|\";\n      stack.push(top);\n    } else if (syntax.startsWith(\"}}\")) {\n      const close = syntax.slice(0, Math.min(open.length, 3)), rest = open.length - close.length, { length } = accum;\n      lastIndex = curIndex + close.length;\n      parts.at(-1).push(text.slice(topPos, curIndex));\n      let skip = false, ch = \"t\";\n      if (close.length === 3) {\n        const ArgToken = __webpack_require__(/*! ../src/arg */ \"./src/arg.js\");\n        new ArgToken(parts.map((part) => part.join(\"=\")), config, accum);\n      } else {\n        const name = removeComment(parts[0][0]);\n        if (name in marks) {\n          ch = marks[name];\n        } else if (/^(?:fullurl|canonicalurl|filepath):./iu.test(name)) {\n          ch = \"m\";\n        }\n        try {\n          const TranscludeToken = __webpack_require__(/*! ../src/transclude */ \"./src/transclude.js\");\n          new TranscludeToken(parts[0][0], parts.slice(1), config, accum);\n        } catch (e) {\n          if (e instanceof Error && e.message.startsWith(\"\\u975E\\u6CD5\\u7684\\u6A21\\u677F\\u540D\\u79F0\\uFF1A\")) {\n            lastIndex = index + open.length;\n            skip = true;\n          } else {\n            throw e;\n          }\n        }\n      }\n      if (!skip) {\n        text = `${text.slice(0, index + rest)}\\0${length}${ch}\\x7F${text.slice(lastIndex)}`;\n        lastIndex = index + rest + 3 + String(length).length;\n        if (rest > 1) {\n          stack.push({ 0: open.slice(0, rest), index, pos: index + rest, parts: [[]] });\n        } else if (rest === 1 && text[index - 1] === \"-\") {\n          stack.push({ 0: \"-{\", index: index - 1, pos: index + 1, parts: [[]] });\n        }\n      }\n    } else {\n      lastIndex = curIndex + syntax.length;\n      if (syntax[0] === \"{\") {\n        mt.pos = lastIndex;\n        mt.parts = [[]];\n      }\n      stack.push(...\"0\" in top ? [top] : [], mt);\n    }\n    moreBraces && (moreBraces = text.slice(lastIndex).includes(\"}}\"));\n    let curTop = stack.at(-1);\n    if (!moreBraces && ((_e = curTop == null ? void 0 : curTop[0]) == null ? void 0 : _e[0]) === \"{\") {\n      stack.pop();\n      curTop = stack.at(-1);\n    }\n    regex = new RegExp(source + (curTop ? `|${closes[curTop[0][0]]}${curTop.findEqual ? \"|=\" : \"\"}` : \"\"), \"gmu\");\n    regex.lastIndex = lastIndex;\n    mt = regex.exec(text);\n  }\n  return text;\n};\nmodule.exports = parseBrackets;\n\n\n//# sourceURL=webpack://wikiparser-node/./parser/brackets.js?");

/***/ }),

/***/ "./parser/commentAndExt.js":
/*!*********************************!*\
  !*** ./parser/commentAndExt.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Parser = __webpack_require__(/*! .. */ \"./index.js\");\nconst parseCommentAndExt = (text, config = Parser.getConfig(), accum = [], includeOnly = false) => {\n  const onlyinclude = /<onlyinclude>(.*?)<\\/onlyinclude>/gsu;\n  if (includeOnly && text.search(onlyinclude) !== -1) {\n    return text.replaceAll(onlyinclude, (_, inner) => {\n      const str = `\\0${accum.length}e\\x7F`;\n      const OnlyincludeToken = __webpack_require__(/*! ../src/onlyinclude */ \"./src/onlyinclude.js\");\n      new OnlyincludeToken(inner, config, accum);\n      return str;\n    }).replaceAll(/(^|\\0\\d+e\\x7F)(.*?)(?=$|\\0\\d+e\\x7F)/gsu, (_, lead, substr) => {\n      if (substr === \"\") {\n        return lead;\n      }\n      const NoincludeToken = __webpack_require__(/*! ../src/nowiki/noinclude */ \"./src/nowiki/noinclude.js\");\n      new NoincludeToken(substr, config, accum);\n      return `${lead}\\0${accum.length - 1}c\\x7F`;\n    });\n  }\n  const ext = config.ext.join(\"|\"), includeRegex = includeOnly ? \"includeonly\" : \"(?:no|only)include\", noincludeRegex = includeOnly ? \"noinclude\" : \"includeonly\", regex = new RegExp(\n    `<!--.*?(?:-->|$)|<${includeRegex}(?:\\\\s[^>]*?)?>|</${includeRegex}\\\\s*>|<(${ext})(\\\\s[^>]*?)?(?:/>|>(.*?)</(\\\\1\\\\s*)>)|<(${noincludeRegex})(\\\\s[^>]*?)?(?:/>|>(.*?)(?:</(\\\\5\\\\s*)>|$))`,\n    \"gisu\"\n  );\n  return text.replaceAll(\n    regex,\n    (substr, name, attr, inner, closing, include, includeAttr, includeInner, includeClosing) => {\n      const str = `\\0${accum.length}${name ? \"e\" : \"c\"}\\x7F`;\n      if (name) {\n        const ExtToken = __webpack_require__(/*! ../src/tagPair/ext */ \"./src/tagPair/ext.js\");\n        new ExtToken(name, attr, inner, closing, config, accum);\n      } else if (substr.startsWith(\"<!--\")) {\n        const CommentToken = __webpack_require__(/*! ../src/nowiki/comment */ \"./src/nowiki/comment.js\");\n        const closed = substr.endsWith(\"-->\");\n        new CommentToken(substr.slice(4, closed ? -3 : void 0), closed, config, accum);\n      } else if (include) {\n        const IncludeToken = __webpack_require__(/*! ../src/tagPair/include */ \"./src/tagPair/include.js\");\n        new IncludeToken(include, includeAttr, includeInner, includeClosing, config, accum);\n      } else {\n        const NoincludeToken = __webpack_require__(/*! ../src/nowiki/noinclude */ \"./src/nowiki/noinclude.js\");\n        new NoincludeToken(substr, config, accum);\n      }\n      return str;\n    }\n  );\n};\nmodule.exports = parseCommentAndExt;\n\n\n//# sourceURL=webpack://wikiparser-node/./parser/commentAndExt.js?");

/***/ }),

/***/ "./parser/converter.js":
/*!*****************************!*\
  !*** ./parser/converter.js ***!
  \*****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Parser = __webpack_require__(/*! .. */ \"./index.js\");\nconst parseConverter = (wikitext, config = Parser.getConfig(), accum = []) => {\n  const ConverterToken = __webpack_require__(/*! ../src/converter */ \"./src/converter.js\");\n  const regex1 = /-\\{/gu, regex2 = /-\\{|\\}-/gu, stack = [];\n  let regex = regex1, mt = regex.exec(wikitext);\n  while (mt) {\n    const { 0: syntax, index } = mt;\n    if (syntax === \"}-\") {\n      const top = stack.pop(), { length } = accum, str = wikitext.slice(top.index + 2, index), i = str.indexOf(\"|\"), [flags, text] = i === -1 ? [[], str] : [str.slice(0, i).split(\";\"), str.slice(i + 1)], temp = text.replaceAll(/(&[#a-z\\d]+);/giu, \"$1\u0001\"), variants = `(?:${config.variants.join(\"|\")})`, rules = temp.split(new RegExp(`;(?=\\\\s*(?:${variants}|[^;]*?=>\\\\s*${variants})\\\\s*:)`, \"u\")).map((rule) => rule.replaceAll(\"\u0001\", \";\"));\n      new ConverterToken(flags, rules, config, accum);\n      wikitext = `${wikitext.slice(0, top.index)}\\0${length}v\\x7F${wikitext.slice(index + 2)}`;\n      if (stack.length === 0) {\n        regex = regex1;\n      }\n      regex.lastIndex = top.index + 3 + String(length).length;\n    } else {\n      stack.push(mt);\n      regex = regex2;\n    }\n    mt = regex.exec(wikitext);\n  }\n  return wikitext;\n};\nmodule.exports = parseConverter;\n\n\n//# sourceURL=webpack://wikiparser-node/./parser/converter.js?");

/***/ }),

/***/ "./parser/externalLinks.js":
/*!*********************************!*\
  !*** ./parser/externalLinks.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { extUrlChar } = __webpack_require__(/*! ../util/string */ \"./util/string.js\"), Parser = __webpack_require__(/*! .. */ \"./index.js\");\nconst parseExternalLinks = (wikitext, config = Parser.getConfig(), accum = []) => {\n  const ExtLinkToken = __webpack_require__(/*! ../src/extLink */ \"./src/extLink.js\");\n  const regex = new RegExp(\n    `\\\\[((?:${config.protocol}|//)${extUrlChar}|\\0\\\\d+m\\x7F)(\\\\p{Zs}*)([^\\\\]\u0001-\\b\n-\u001f\\uFFFD]*)\\\\]`,\n    \"giu\"\n  );\n  return wikitext.replaceAll(regex, (_, url, space, text) => {\n    const { length } = accum, mt = /&[lg]t;/u.exec(url);\n    if (mt) {\n      url = url.slice(0, mt.index);\n      space = \"\";\n      text = `${url.slice(mt.index)}${space}${text}`;\n    }\n    new ExtLinkToken(url, space, text, config, accum);\n    return `\\0${length}w\\x7F`;\n  });\n};\nmodule.exports = parseExternalLinks;\n\n\n//# sourceURL=webpack://wikiparser-node/./parser/externalLinks.js?");

/***/ }),

/***/ "./parser/hrAndDoubleUnderscore.js":
/*!*****************************************!*\
  !*** ./parser/hrAndDoubleUnderscore.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Parser = __webpack_require__(/*! .. */ \"./index.js\");\nconst parseHrAndDoubleUnderscore = ({ firstChild: { data }, type, name }, config = Parser.getConfig(), accum = []) => {\n  const AstText = __webpack_require__(/*! ../lib/text */ \"./lib/text.js\"), Token = __webpack_require__(/*! ../src */ \"./src/index.js\"), HrToken = __webpack_require__(/*! ../src/nowiki/hr */ \"./src/nowiki/hr.js\"), DoubleUnderscoreToken = __webpack_require__(/*! ../src/nowiki/doubleUnderscore */ \"./src/nowiki/doubleUnderscore.js\");\n  const { doubleUnderscore } = config;\n  if (type !== \"root\" && (type !== \"ext-inner\" || name !== \"poem\")) {\n    data = `\\0${data}`;\n  }\n  data = data.replaceAll(/^((?:\\0\\d+c\\x7F)*)(-{4,})/gmu, (_, lead, m) => {\n    new HrToken(m.length, config, accum);\n    return `${lead}\\0${accum.length - 1}r\\x7F`;\n  }).replaceAll(\n    new RegExp(`__(${doubleUnderscore.flat().join(\"|\")})__`, \"giu\"),\n    (m, p1) => {\n      if (doubleUnderscore[0].includes(p1.toLowerCase()) || doubleUnderscore[1].includes(p1)) {\n        new DoubleUnderscoreToken(p1, config, accum);\n        return `\\0${accum.length - 1}u\\x7F`;\n      }\n      return m;\n    }\n  );\n  return type === \"root\" || type === \"ext-inner\" && name === \"poem\" ? data : data.slice(1);\n};\nmodule.exports = parseHrAndDoubleUnderscore;\n\n\n//# sourceURL=webpack://wikiparser-node/./parser/hrAndDoubleUnderscore.js?");

/***/ }),

/***/ "./parser/html.js":
/*!************************!*\
  !*** ./parser/html.js ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Parser = __webpack_require__(/*! .. */ \"./index.js\");\nconst parseHtml = (wikitext, config = Parser.getConfig(), accum = []) => {\n  const regex = /^(\\/?)([a-z][^\\s/>]*)(\\s[^>]*?)?(\\/?>)([^<]*)$/iu, elements = config.html.flat(), bits = wikitext.split(\"<\");\n  let text = bits.shift();\n  for (const x of bits) {\n    const mt = regex.exec(x), t = mt == null ? void 0 : mt[2], name = t == null ? void 0 : t.toLowerCase();\n    if (!mt || !elements.includes(name)) {\n      text += `<${x}`;\n      continue;\n    }\n    const AttributeToken = __webpack_require__(/*! ../src/attribute */ \"./src/attribute.js\");\n    const [, slash, , params = \"\", brace, rest] = mt, attr = new AttributeToken(params, \"html-attr\", config, accum), itemprop = attr.getAttr(\"itemprop\");\n    if (name === \"meta\" && (itemprop === void 0 || attr.getAttr(\"content\") === void 0) || name === \"link\" && (itemprop === void 0 || attr.getAttr(\"href\") === void 0)) {\n      text += `<${x}`;\n      accum.pop();\n      continue;\n    }\n    text += `\\0${accum.length}x\\x7F${rest}`;\n    const HtmlToken = __webpack_require__(/*! ../src/html */ \"./src/html.js\");\n    new HtmlToken(t, attr, slash === \"/\", brace === \"/>\", config, accum);\n  }\n  return text;\n};\nmodule.exports = parseHtml;\n\n\n//# sourceURL=webpack://wikiparser-node/./parser/html.js?");

/***/ }),

/***/ "./parser/links.js":
/*!*************************!*\
  !*** ./parser/links.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Parser = __webpack_require__(/*! .. */ \"./index.js\");\nconst parseLinks = (wikitext, config = Parser.getConfig(), accum = []) => {\n  const parseQuotes = __webpack_require__(/*! ./quotes.js */ \"./parser/quotes.js\");\n  const regex = /^([^\\n<>[\\]{}|]+)(?:\\|(.*?[^\\]]))?\\]\\](.*)$/su, regexImg = /^([^\\n<>[\\]{}|]+)\\|(.*)$/su, regexExt = new RegExp(`^\\\\s*(?:${config.protocol})`, \"iu\"), bits = wikitext.split(\"[[\");\n  let s = bits.shift();\n  for (let i = 0; i < bits.length; i++) {\n    let mightBeImg, link, text, after;\n    const x = bits[i], m = regex.exec(x);\n    if (m) {\n      [, link, text, after] = m;\n      if (after[0] === \"]\" && (text == null ? void 0 : text.includes(\"[\"))) {\n        text += \"]\";\n        after = after.slice(1);\n      }\n    } else {\n      const m2 = regexImg.exec(x);\n      if (m2) {\n        mightBeImg = true;\n        [, link, text] = m2;\n      }\n    }\n    if (link === void 0 || regexExt.test(link) || /\\0\\d+[exhbru]\\x7F/u.test(link)) {\n      s += `[[${x}`;\n      continue;\n    }\n    let page = link;\n    if (link.includes(\"%\")) {\n      try {\n        page = decodeURIComponent(link);\n      } catch (e) {\n      }\n    }\n    const force = link.trim()[0] === \":\";\n    if (force && mightBeImg) {\n      s += `[[${x}`;\n      continue;\n    }\n    const { ns, valid } = Parser.normalizeTitle(page, 0, config, true);\n    if (!valid) {\n      s += `[[${x}`;\n      continue;\n    } else if (mightBeImg) {\n      if (ns !== 6) {\n        s += `[[${x}`;\n        continue;\n      }\n      let found;\n      for (i++; i < bits.length; i++) {\n        const next = bits[i], p = next.split(\"]]\");\n        if (p.length > 2) {\n          found = true;\n          text += `[[${p[0]}]]${p[1]}`;\n          after = p.slice(2).join(\"]]\");\n          break;\n        } else if (p.length === 2) {\n          text += `[[${p[0]}]]${p[1]}`;\n        } else {\n          text += `[[${next}`;\n          break;\n        }\n      }\n      text = parseLinks(text, config, accum);\n      if (!found) {\n        s += `[[${link}|${text}`;\n        continue;\n      }\n    }\n    text && (text = parseQuotes(text, config, accum));\n    s += `\\0${accum.length}l\\x7F${after}`;\n    let LinkToken = __webpack_require__(/*! ../src/link */ \"./src/link/index.js\");\n    if (!force) {\n      if (ns === 6) {\n        LinkToken = __webpack_require__(/*! ../src/link/file */ \"./src/link/file.js\");\n      } else if (ns === 14) {\n        LinkToken = __webpack_require__(/*! ../src/link/category */ \"./src/link/category.js\");\n      }\n    }\n    new LinkToken(link, text, config, accum);\n  }\n  return s;\n};\nmodule.exports = parseLinks;\n\n\n//# sourceURL=webpack://wikiparser-node/./parser/links.js?");

/***/ }),

/***/ "./parser/list.js":
/*!************************!*\
  !*** ./parser/list.js ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Parser = __webpack_require__(/*! .. */ \"./index.js\");\nconst parseList = (text, config = Parser.getConfig(), accum = []) => {\n  const mt = /^((?:\\0\\d+c\\x7F)*)([;:*#]+)/u.exec(text);\n  if (!mt) {\n    return text;\n  }\n  const ListToken = __webpack_require__(/*! ../src/nowiki/list */ \"./src/nowiki/list.js\");\n  const [total, comment, prefix] = mt;\n  text = `${comment}\\0${accum.length}d\\x7F${text.slice(total.length)}`;\n  new ListToken(prefix, config, accum);\n  let dt = prefix.split(\";\").length - 1;\n  if (!dt) {\n    return text;\n  }\n  const DdToken = __webpack_require__(/*! ../src/nowiki/dd */ \"./src/nowiki/dd.js\");\n  let regex = /:+|-\\{/gu, ex = regex.exec(text), lc = 0;\n  while (ex && dt) {\n    const { 0: syntax, index } = ex;\n    if (syntax[0] === \":\") {\n      if (syntax.length >= dt) {\n        new DdToken(\":\".repeat(dt), config, accum);\n        return `${text.slice(0, index)}\\0${accum.length - 1}d\\x7F${text.slice(index + dt)}`;\n      }\n      text = `${text.slice(0, index)}\\0${accum.length}d\\x7F${text.slice(regex.lastIndex)}`;\n      dt -= syntax.length;\n      regex.lastIndex = index + 4 + String(accum.length).length;\n      new DdToken(syntax, config, accum);\n    } else if (syntax === \"-{\") {\n      if (!lc) {\n        const { lastIndex } = regex;\n        regex = /-\\{|\\}-/gu;\n        regex.lastIndex = lastIndex;\n      }\n      lc++;\n    } else {\n      lc--;\n      if (!lc) {\n        const { lastIndex } = regex;\n        regex = /:+|-\\{/gu;\n        regex.lastIndex = lastIndex;\n      }\n    }\n    ex = regex.exec(text);\n  }\n  return text;\n};\nmodule.exports = parseList;\n\n\n//# sourceURL=webpack://wikiparser-node/./parser/list.js?");

/***/ }),

/***/ "./parser/magicLinks.js":
/*!******************************!*\
  !*** ./parser/magicLinks.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { extUrlChar } = __webpack_require__(/*! ../util/string */ \"./util/string.js\"), Parser = __webpack_require__(/*! .. */ \"./index.js\");\nconst parseMagicLinks = (wikitext, config = Parser.getConfig(), accum = []) => {\n  const MagicLinkToken = __webpack_require__(/*! ../src/magicLink */ \"./src/magicLink.js\");\n  const regex = new RegExp(`\\\\b(?:${config.protocol})(${extUrlChar})`, \"giu\");\n  return wikitext.replaceAll(regex, (m, p1) => {\n    let trail = \"\", url = m;\n    const m2 = /&(?:lt|gt|nbsp|#x0*(?:3[ce]|a0)|#0*(?:6[02]|160));/iu.exec(url);\n    if (m2) {\n      trail = url.slice(m2.index);\n      url = url.slice(0, m2.index);\n    }\n    const sep = new RegExp(`[,;.:!?${url.includes(\"(\") ? \"\" : \")\"}]+$`, \"u\"), sepChars = sep.exec(url);\n    if (sepChars) {\n      let correction = 0;\n      if (sepChars[0][0] === \";\" && /&(?:[a-z]+|#x[\\da-f]+|#\\d+)$/iu.test(url.slice(0, sepChars.index))) {\n        correction = 1;\n      }\n      trail = `${url.slice(sepChars.index + correction)}${trail}`;\n      url = url.slice(0, sepChars.index + correction);\n    }\n    if (trail.length >= p1.length) {\n      return m;\n    }\n    new MagicLinkToken(url, false, config, accum);\n    return `\\0${accum.length - 1}w\\x7F${trail}`;\n  });\n};\nmodule.exports = parseMagicLinks;\n\n\n//# sourceURL=webpack://wikiparser-node/./parser/magicLinks.js?");

/***/ }),

/***/ "./parser/quotes.js":
/*!**************************!*\
  !*** ./parser/quotes.js ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Parser = __webpack_require__(/*! .. */ \"./index.js\");\nconst parseQuotes = (text, config = Parser.getConfig(), accum = []) => {\n  var _a;\n  const arr = text.split(/('{2,})/u), { length } = arr;\n  if (length === 1) {\n    return text;\n  }\n  let nBold = 0, nItalic = 0, firstSingle, firstMulti, firstSpace;\n  for (let i = 1; i < length; i += 2) {\n    const { length: len } = arr[i];\n    switch (len) {\n      case 2:\n        nItalic++;\n        break;\n      case 4:\n        arr[i - 1] += \"'\";\n        arr[i] = \"'''\";\n      case 3:\n        nBold++;\n        if (firstSingle) {\n          break;\n        } else if (arr[i - 1].at(-1) === \" \") {\n          if (!firstMulti && !firstSpace) {\n            firstSpace = i;\n          }\n        } else if (arr[i - 1].at(-2) === \" \") {\n          firstSingle = i;\n        } else {\n          firstMulti || (firstMulti = i);\n        }\n        break;\n      default:\n        arr[i - 1] += \"'\".repeat(len - 5);\n        arr[i] = \"'''''\";\n        nItalic++;\n        nBold++;\n    }\n  }\n  if (nItalic % 2 === 1 && nBold % 2 === 1) {\n    const i = (_a = firstSingle != null ? firstSingle : firstMulti) != null ? _a : firstSpace;\n    arr[i] = \"''\";\n    arr[i - 1] += \"'\";\n  }\n  const QuoteToken = __webpack_require__(/*! ../src/nowiki/quote */ \"./src/nowiki/quote.js\");\n  for (let i = 1; i < length; i += 2) {\n    new QuoteToken(arr[i].length, config, accum);\n    arr[i] = `\\0${accum.length - 1}q\\x7F`;\n  }\n  return arr.join(\"\");\n};\nmodule.exports = parseQuotes;\n\n\n//# sourceURL=webpack://wikiparser-node/./parser/quotes.js?");

/***/ }),

/***/ "./parser/table.js":
/*!*************************!*\
  !*** ./parser/table.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Parser = __webpack_require__(/*! .. */ \"./index.js\"), AstText = __webpack_require__(/*! ../lib/text */ \"./lib/text.js\"), Token = __webpack_require__(/*! ../src */ \"./src/index.js\"), TableToken = __webpack_require__(/*! ../src/table */ \"./src/table/index.js\"), TrToken = __webpack_require__(/*! ../src/table/tr */ \"./src/table/tr.js\"), TdToken = __webpack_require__(/*! ../src/table/td */ \"./src/table/td.js\");\nconst parseTable = ({ firstChild: { data }, type, name }, config = Parser.getConfig(), accum = []) => {\n  const stack = [], lines = data.split(\"\\n\");\n  let out = type === \"root\" || type === \"ext-inner\" && name === \"poem\" ? \"\" : `\n${lines.shift()}`;\n  const push = (str, top) => {\n    if (!top) {\n      out += str;\n      return;\n    }\n    const { lastChild } = top;\n    if (lastChild.constructor === Token) {\n      lastChild.setText(String(lastChild) + str);\n    } else {\n      const token = new Token(str, config, true, accum);\n      token.type = \"table-inter\";\n      top.insertAt(token.setAttribute(\"stage\", 3));\n    }\n  };\n  for (const outLine of lines) {\n    let top = stack.pop();\n    const [spaces] = /^(?:\\s|\\0\\d+c\\x7F)*/u.exec(outLine), line = outLine.slice(spaces.length), matchesStart = /^(:*)((?:\\s|\\0\\d+c\\x7F)*)(\\{\\||\\{\\0\\d+!\\x7F|\\0\\d+\\{\\x7F)(.*)$/u.exec(line);\n    if (matchesStart) {\n      while (top && top.type !== \"td\") {\n        top = stack.pop();\n      }\n      const [, indent, moreSpaces, tableSyntax, attr2] = matchesStart;\n      if (indent) {\n        const DdToken = __webpack_require__(/*! ../src/nowiki/dd */ \"./src/nowiki/dd.js\");\n        new DdToken(indent, config, accum);\n      }\n      push(`\n${spaces}${indent && `\\0${accum.length - 1}d\\x7F`}${moreSpaces}\\0${accum.length}b\\x7F`, top);\n      const table = new TableToken(tableSyntax, attr2, config, accum);\n      stack.push(...top ? [top] : [], table);\n      continue;\n    } else if (!top) {\n      out += `\n${outLine}`;\n      continue;\n    }\n    const matches = /^(?:(\\|\\}|\\0\\d+!\\x7F\\}|\\0\\d+\\}\\x7F)|(\\|-+|\\0\\d+!\\x7F-+|\\0\\d+-\\x7F-*)(?!-)|(!|(?:\\||\\0\\d+!\\x7F)\\+?))(.*)$/u.exec(line);\n    if (!matches) {\n      push(`\n${outLine}`, top);\n      stack.push(...top ? [top] : []);\n      continue;\n    }\n    const [, closing, row, cell, attr] = matches;\n    if (closing) {\n      while (!(top instanceof TableToken)) {\n        top = stack.pop();\n      }\n      top.close(`\n${spaces}${closing}`, true);\n      push(attr, stack.at(-1));\n    } else if (row) {\n      if (top.type === \"td\") {\n        top = stack.pop();\n      }\n      if (top.type === \"tr\") {\n        top = stack.pop();\n      }\n      const tr = new TrToken(`\n${spaces}${row}`, attr, config, accum);\n      stack.push(top, tr);\n      top.insertAt(tr);\n    } else {\n      if (top.type === \"td\") {\n        top = stack.pop();\n      }\n      const regex = cell === \"!\" ? /!!|(?:\\||\\0\\d+!\\x7F){2}|\\0\\d+\\+\\x7F/gu : /(?:\\||\\0\\d+!\\x7F){2}|\\0\\d+\\+\\x7F/gu;\n      let mt = regex.exec(attr), lastIndex = 0, lastSyntax = `\n${spaces}${cell}`;\n      while (mt) {\n        const td2 = new TdToken(lastSyntax, attr.slice(lastIndex, mt.index), config, accum);\n        top.insertAt(td2);\n        ({ lastIndex } = regex);\n        [lastSyntax] = mt;\n        mt = regex.exec(attr);\n      }\n      const td = new TdToken(lastSyntax, attr.slice(lastIndex), config, accum);\n      stack.push(top, td);\n      top.insertAt(td);\n    }\n  }\n  return out.slice(1);\n};\nmodule.exports = parseTable;\n\n\n//# sourceURL=webpack://wikiparser-node/./parser/table.js?");

/***/ }),

/***/ "./src/arg.js":
/*!********************!*\
  !*** ./src/arg.js ***!
  \********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst { generateForChild } = __webpack_require__(/*! ../util/lint */ \"./util/lint.js\"), Parser = __webpack_require__(/*! .. */ \"./index.js\"), Token = __webpack_require__(/*! . */ \"./src/index.js\");\nclass ArgToken extends Token {\n  constructor(parts, config = Parser.getConfig(), accum = []) {\n    super(void 0, config, true, accum);\n    __publicField(this, \"type\", \"arg\");\n    for (let i = 0; i < parts.length; i++) {\n      if (i === 0 || i > 1) {\n        const AtomToken = i === 0 ? __webpack_require__(/*! ./atom */ \"./src/atom/index.js\") : __webpack_require__(/*! ./atom/hidden */ \"./src/atom/hidden.js\");\n        const token = new AtomToken(parts[i], i === 0 ? \"arg-name\" : void 0, config, accum);\n        this.insertAt(token);\n      } else {\n        const token = new Token(parts[i], config, true, accum);\n        token.type = \"arg-default\";\n        this.insertAt(token.setAttribute(\"stage\", 2));\n      }\n    }\n  }\n  toString() {\n    return `{{{${super.toString(\"|\")}}}}`;\n  }\n  getPadding() {\n    return 3;\n  }\n  getGaps() {\n    return 1;\n  }\n  print() {\n    return super.print({ pre: \"{{{\", post: \"}}}\", sep: \"|\" });\n  }\n  lint(start = 0) {\n    const { childNodes: [argName, argDefault, ...rest] } = this, errors = argName.lint(start + 3);\n    if (argDefault) {\n      errors.push(...argDefault.lint(start + 4 + String(argName).length));\n    }\n    if (rest.length > 0) {\n      const rect = this.getRootNode().posFromIndex(start);\n      errors.push(...rest.map((child) => generateForChild(child, rect, \"\\u4E09\\u91CD\\u62EC\\u53F7\\u5185\\u7684\\u4E0D\\u53EF\\u89C1\\u90E8\\u5206\")));\n    }\n    return errors;\n  }\n}\nmodule.exports = ArgToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/arg.js?");

/***/ }),

/***/ "./src/atom/hidden.js":
/*!****************************!*\
  !*** ./src/atom/hidden.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst hidden = __webpack_require__(/*! ../../mixin/hidden */ \"./mixin/hidden.js\"), AtomToken = __webpack_require__(/*! . */ \"./src/atom/index.js\");\nclass HiddenToken extends hidden(AtomToken) {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"type\", \"hidden\");\n  }\n}\nmodule.exports = HiddenToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/atom/hidden.js?");

/***/ }),

/***/ "./src/atom/index.js":
/*!***************************!*\
  !*** ./src/atom/index.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst Parser = __webpack_require__(/*! ../.. */ \"./index.js\"), Token = __webpack_require__(/*! .. */ \"./src/index.js\");\nclass AtomToken extends Token {\n  constructor(wikitext, type, config = Parser.getConfig(), accum = []) {\n    super(wikitext, config, true, accum);\n    __publicField(this, \"type\", \"plain\");\n    if (type) {\n      this.type = type;\n    }\n  }\n}\nmodule.exports = AtomToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/atom/index.js?");

/***/ }),

/***/ "./src/attribute.js":
/*!**************************!*\
  !*** ./src/attribute.js ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\nvar _attr, _sanitized, _quoteBalance, _parseAttr, parseAttr_fn;\nconst { generateForSelf } = __webpack_require__(/*! ../util/lint */ \"./util/lint.js\"), { removeComment } = __webpack_require__(/*! ../util/string */ \"./util/string.js\"), Parser = __webpack_require__(/*! .. */ \"./index.js\"), Token = __webpack_require__(/*! . */ \"./src/index.js\");\nclass AttributeToken extends Token {\n  constructor(attr, type, config = Parser.getConfig(), accum = []) {\n    super(attr, config, true, accum);\n    __privateAdd(this, _parseAttr);\n    __privateAdd(this, _attr, /* @__PURE__ */ new Map());\n    __privateAdd(this, _sanitized, true);\n    __privateAdd(this, _quoteBalance, true);\n    this.type = type;\n    __privateMethod(this, _parseAttr, parseAttr_fn).call(this);\n  }\n  getAttr(key) {\n    return __privateGet(this, _attr).get(key.toLowerCase().trim());\n  }\n  setAttr(key, value) {\n    key = key.toLowerCase().trim();\n    if (/^(?:[\\w:]|\\0\\d+[t!~{}+-]\\x7F)(?:[\\w:.-]|\\0\\d+[t!~{}+-]\\x7F)*$/u.test(key)) {\n      __privateGet(this, _attr).set(key, value === true ? true : value.replaceAll(/\\s/gu, \" \").trim());\n      return true;\n    }\n    return false;\n  }\n  lint(start = 0) {\n    const HtmlToken = __webpack_require__(/*! ./html */ \"./src/html.js\");\n    const errors = super.lint(start);\n    let rect;\n    if (this.type === \"html-attr\" && this.parentNode.closing && String(this).trim()) {\n      rect = this.getRootNode().posFromIndex(start);\n      errors.push(generateForSelf(this, rect, \"\\u4F4D\\u4E8E\\u95ED\\u5408\\u6807\\u7B7E\\u7684\\u5C5E\\u6027\"));\n    }\n    if (!__privateGet(this, _sanitized)) {\n      rect || (rect = this.getRootNode().posFromIndex(start));\n      errors.push(generateForSelf(this, rect, \"\\u5305\\u542B\\u65E0\\u6548\\u5C5E\\u6027\"));\n    } else if (!__privateGet(this, _quoteBalance)) {\n      rect || (rect = this.getRootNode().posFromIndex(start));\n      errors.push(generateForSelf(this, rect, \"\\u672A\\u95ED\\u5408\\u7684\\u5F15\\u53F7\", \"warning\"));\n    }\n    return errors;\n  }\n}\n_attr = new WeakMap();\n_sanitized = new WeakMap();\n_quoteBalance = new WeakMap();\n_parseAttr = new WeakSet();\nparseAttr_fn = function() {\n  var _a;\n  let string = this.toString();\n  string = removeComment(string).replaceAll(/\\0\\d+~\\x7F/gu, \"=\");\n  for (const [, key, quoteStart, quoted, quoteEnd, unquoted] of string.matchAll(/([^\\s/][^\\s/=]*)(?:\\s*=\\s*(?:([\"'])(.*?)(\\2|$)|(\\S*)))?/gsu)) {\n    if (!this.setAttr(key, (_a = quoted != null ? quoted : unquoted) != null ? _a : true, true)) {\n      __privateSet(this, _sanitized, false);\n    } else if (quoteStart !== quoteEnd) {\n      __privateSet(this, _quoteBalance, false);\n    }\n  }\n};\nmodule.exports = AttributeToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/attribute.js?");

/***/ }),

/***/ "./src/converter.js":
/*!**************************!*\
  !*** ./src/converter.js ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst { print } = __webpack_require__(/*! ../util/string */ \"./util/string.js\"), Parser = __webpack_require__(/*! .. */ \"./index.js\"), Token = __webpack_require__(/*! . */ \"./src/index.js\"), ConverterFlagsToken = __webpack_require__(/*! ./converterFlags */ \"./src/converterFlags.js\"), ConverterRuleToken = __webpack_require__(/*! ./converterRule */ \"./src/converterRule.js\");\nclass ConverterToken extends Token {\n  constructor(flags, rules, config = Parser.getConfig(), accum = []) {\n    super(void 0, config, true, accum);\n    __publicField(this, \"type\", \"converter\");\n    this.append(new ConverterFlagsToken(flags, config, accum));\n    const [firstRule] = rules, hasColon = firstRule.includes(\":\"), firstRuleToken = new ConverterRuleToken(firstRule, hasColon, config, accum);\n    if (hasColon && firstRuleToken.childNodes.length === 1) {\n      this.insertAt(new ConverterRuleToken(rules.join(\";\"), false, config, accum));\n    } else {\n      this.append(\n        firstRuleToken,\n        ...rules.slice(1).map((rule) => new ConverterRuleToken(rule, true, config, accum))\n      );\n    }\n  }\n  toString() {\n    const { childNodes: [flags, ...rules] } = this;\n    return `-{${flags.toString()}${flags.childNodes.length > 0 ? \"|\" : \"\"}${rules.map(String).join(\";\")}}-`;\n  }\n  getPadding() {\n    return 2;\n  }\n  getGaps(i = 0) {\n    i = i < 0 ? i + this.childNodes.length : i;\n    return i || this.firstChild.childNodes.length > 0 ? 1 : 0;\n  }\n  print() {\n    const { children: [flags, ...rules] } = this;\n    return `<span class=\"wpb-converter\">-{${flags.print()}${flags.childNodes.length > 0 ? \"|\" : \"\"}${print(rules, { sep: \";\" })}}-</span>`;\n  }\n}\nmodule.exports = ConverterToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/converter.js?");

/***/ }),

/***/ "./src/converterFlags.js":
/*!*******************************!*\
  !*** ./src/converterFlags.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _flags;\nconst { generateForChild } = __webpack_require__(/*! ../util/lint */ \"./util/lint.js\"), Parser = __webpack_require__(/*! .. */ \"./index.js\"), Token = __webpack_require__(/*! . */ \"./src/index.js\"), AtomToken = __webpack_require__(/*! ./atom */ \"./src/atom/index.js\");\nclass ConverterFlagsToken extends Token {\n  constructor(flags, config = Parser.getConfig(), accum = []) {\n    super(void 0, config, true, accum);\n    __publicField(this, \"type\", \"converter-flags\");\n    __privateAdd(this, _flags, void 0);\n    this.append(...flags.map((flag) => new AtomToken(flag, \"converter-flag\", config, accum)));\n  }\n  afterBuild() {\n    __privateSet(this, _flags, this.childNodes.map((child) => String(child).trim()));\n    return this;\n  }\n  toString() {\n    return super.toString(\";\");\n  }\n  getGaps() {\n    return 1;\n  }\n  print() {\n    return super.print({ sep: \";\" });\n  }\n  lint(start = 0) {\n    const variantFlags = this.getVariantFlags(), unknownFlags = this.getUnknownFlags(), emptyFlags = __privateGet(this, _flags).filter((flag) => !flag), validFlags = __privateGet(this, _flags).filter((flag) => [\"A\", \"T\", \"R\", \"D\", \"-\", \"H\", \"N\"].includes(flag)), knownFlagCount = __privateGet(this, _flags).length - unknownFlags.length - emptyFlags, errors = super.lint(start);\n    if (variantFlags.length === knownFlagCount || validFlags.length === knownFlagCount) {\n      return errors;\n    }\n    const rect = this.getRootNode().posFromIndex(start);\n    for (const child of this.childNodes) {\n      const flag = String(child).trim();\n      if (flag && !variantFlags.includes(flag) && !unknownFlags.includes(flag) && (variantFlags.length > 0 || !validFlags.includes(flag))) {\n        errors.push(generateForChild(child, rect, \"\\u65E0\\u6548\\u7684\\u8F6C\\u6362\\u6807\\u8BB0\"));\n      }\n    }\n    return errors;\n  }\n  getUnknownFlags() {\n    return __privateGet(this, _flags).filter((flag) => /\\{\\{[^{}]+\\}\\}/u.test(flag));\n  }\n  getVariantFlags() {\n    const { variants } = this.getAttribute(\"config\");\n    return __privateGet(this, _flags).filter((flag) => variants.includes(flag));\n  }\n}\n_flags = new WeakMap();\nmodule.exports = ConverterFlagsToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/converterFlags.js?");

/***/ }),

/***/ "./src/converterRule.js":
/*!******************************!*\
  !*** ./src/converterRule.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst Parser = __webpack_require__(/*! .. */ \"./index.js\"), Token = __webpack_require__(/*! . */ \"./src/index.js\"), AtomToken = __webpack_require__(/*! ./atom */ \"./src/atom/index.js\");\nclass ConverterRuleToken extends Token {\n  constructor(rule, hasColon = true, config = Parser.getConfig(), accum = []) {\n    super(void 0, config, true, accum);\n    __publicField(this, \"type\", \"converter-rule\");\n    if (hasColon) {\n      const i = rule.indexOf(\":\"), j = rule.slice(0, i).indexOf(\"=>\"), v = j === -1 ? rule.slice(0, i) : rule.slice(j + 2, i), { variants } = config;\n      if (variants.includes(v.trim())) {\n        super.insertAt(new AtomToken(v, \"converter-rule-variant\", config, accum));\n        super.insertAt(new AtomToken(rule.slice(i + 1), \"converter-rule-to\", config, accum));\n        if (j !== -1) {\n          super.insertAt(new AtomToken(rule.slice(0, j), \"converter-rule-from\", config, accum), 0);\n        }\n      } else {\n        super.insertAt(new AtomToken(rule, \"converter-rule-noconvert\", config, accum));\n      }\n    } else {\n      super.insertAt(new AtomToken(rule, \"converter-rule-noconvert\", config, accum));\n    }\n  }\n  toString() {\n    if (this.childNodes.length === 3) {\n      const { childNodes: [from, variant, to] } = this;\n      return `${from.toString()}=>${variant.toString()}:${to.toString()}`;\n    }\n    return super.toString(\":\");\n  }\n  getGaps(i = 0) {\n    const { length } = this;\n    i = i < 0 ? i + length : i;\n    return i === 0 && length === 3 ? 2 : 1;\n  }\n  print() {\n    if (this.childNodes.length === 3) {\n      const { childNodes: [from, variant, to] } = this;\n      return `<span class=\"wpb-converter-rule\">${from.print()}=>${variant.print()}:${to.print()}</span>`;\n    }\n    return super.print({ sep: \":\" });\n  }\n}\nmodule.exports = ConverterRuleToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/converterRule.js?");

/***/ }),

/***/ "./src/extLink.js":
/*!************************!*\
  !*** ./src/extLink.js ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _space;\nconst Parser = __webpack_require__(/*! .. */ \"./index.js\"), Token = __webpack_require__(/*! . */ \"./src/index.js\"), MagicLinkToken = __webpack_require__(/*! ./magicLink */ \"./src/magicLink.js\");\nclass ExtLinkToken extends Token {\n  constructor(url, space, text, config = Parser.getConfig(), accum = []) {\n    super(void 0, config, true, accum);\n    __publicField(this, \"type\", \"ext-link\");\n    __privateAdd(this, _space, void 0);\n    this.insertAt(new MagicLinkToken(url, true, config, accum));\n    __privateSet(this, _space, space);\n    if (text) {\n      const inner = new Token(text, config, true, accum);\n      inner.type = \"ext-link-text\";\n      this.insertAt(inner.setAttribute(\"stage\", Parser.MAX_STAGE - 1));\n    }\n  }\n  toString() {\n    return this.childNodes.length === 1 ? `[${super.toString()}${__privateGet(this, _space)}]` : `[${super.toString(__privateGet(this, _space))}]`;\n  }\n  getPadding() {\n    return 1;\n  }\n  getGaps() {\n    return __privateGet(this, _space).length;\n  }\n  print() {\n    const { length } = this;\n    return super.print(length > 1 ? { pre: \"[\", sep: __privateGet(this, _space), post: \"]\" } : { pre: \"[\", post: `${__privateGet(this, _space)}]` });\n  }\n}\n_space = new WeakMap();\nmodule.exports = ExtLinkToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/extLink.js?");

/***/ }),

/***/ "./src/gallery.js":
/*!************************!*\
  !*** ./src/gallery.js ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst Parser = __webpack_require__(/*! .. */ \"./index.js\"), Token = __webpack_require__(/*! . */ \"./src/index.js\"), GalleryImageToken = __webpack_require__(/*! ./link/galleryImage */ \"./src/link/galleryImage.js\"), HiddenToken = __webpack_require__(/*! ./atom/hidden */ \"./src/atom/hidden.js\");\nclass GalleryToken extends Token {\n  constructor(inner, config = Parser.getConfig(), accum = []) {\n    var _a;\n    super(void 0, config, true, accum);\n    __publicField(this, \"type\", \"ext-inner\");\n    __publicField(this, \"name\", \"gallery\");\n    for (const line of (_a = inner == null ? void 0 : inner.split(\"\\n\")) != null ? _a : []) {\n      const matches = /^([^|]+)(?:\\|(.*))?/u.exec(line);\n      if (!matches) {\n        this.insertAt(line.trim() ? new HiddenToken(line, void 0, config, [], { AstText: \":\" }) : line);\n        continue;\n      }\n      const [, file, alt] = matches;\n      let valid;\n      try {\n        ({ valid } = this.normalizeTitle(decodeURIComponent(file), 6, true));\n      } catch (e) {\n        ({ valid } = this.normalizeTitle(file, 6, true));\n      }\n      if (valid) {\n        this.insertAt(new GalleryImageToken(file, alt, config, accum));\n      } else {\n        this.insertAt(new HiddenToken(line, void 0, config, []));\n      }\n    }\n  }\n  toString() {\n    return super.toString(\"\\n\");\n  }\n  getGaps() {\n    return 1;\n  }\n  print() {\n    return super.print({ sep: \"\\n\" });\n  }\n  lint(start = 0) {\n    const { top, left } = this.getRootNode().posFromIndex(start), errors = [];\n    for (let i = 0, cur = start; i < this.childNodes.length; i++) {\n      const child = this.childNodes[i], str = String(child), trimmed = str.trim();\n      if (child.type === \"hidden\" && trimmed && !/^<!--.*-->$/u.test(trimmed)) {\n        errors.push({\n          message: \"\\u56FE\\u5E93\\u4E2D\\u7684\\u65E0\\u6548\\u5185\\u5BB9\",\n          startLine: top + i,\n          endLine: top + i,\n          startCol: i ? 0 : left,\n          endCol: i ? str.length : left + str.length\n        });\n      } else if (child.type !== \"hidden\" && child.type !== \"text\") {\n        errors.push(...child.lint(cur));\n      }\n      cur += str.length + 1;\n    }\n    return errors;\n  }\n}\nmodule.exports = GalleryToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/gallery.js?");

/***/ }),

/***/ "./src/heading.js":
/*!************************!*\
  !*** ./src/heading.js ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst { generateForSelf } = __webpack_require__(/*! ../util/lint */ \"./util/lint.js\"), Parser = __webpack_require__(/*! .. */ \"./index.js\"), Token = __webpack_require__(/*! . */ \"./src/index.js\");\nclass HeadingToken extends Token {\n  constructor(level, input, config = Parser.getConfig(), accum = []) {\n    super(void 0, config, true, accum);\n    __publicField(this, \"type\", \"heading\");\n    this.setAttribute(\"name\", String(level));\n    const token = new Token(input[0], config, true, accum);\n    token.type = \"heading-title\";\n    token.setAttribute(\"stage\", 2);\n    const SyntaxToken = __webpack_require__(/*! ./syntax */ \"./src/syntax.js\");\n    const trail = new SyntaxToken(input[1], \"heading-trail\", config, accum);\n    this.append(token, trail);\n  }\n  toString() {\n    const equals = \"=\".repeat(Number(this.name));\n    return `${equals}${this.firstChild.toString()}${equals}${this.lastChild.toString()}`;\n  }\n  getPadding() {\n    return Number(this.name);\n  }\n  getGaps() {\n    return Number(this.name);\n  }\n  print() {\n    const equals = \"=\".repeat(Number(this.name));\n    return super.print({ pre: equals, sep: equals });\n  }\n  lint(start = 0) {\n    const errors = super.lint(start);\n    if (this.name === \"1\") {\n      errors.push(generateForSelf(this, this.getRootNode().posFromIndex(start), \"<h1>\"));\n    }\n    return errors;\n  }\n}\nmodule.exports = HeadingToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/heading.js?");

/***/ }),

/***/ "./src/html.js":
/*!*********************!*\
  !*** ./src/html.js ***!
  \*********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _closing, _selfClosing, _tag;\nconst { generateForSelf } = __webpack_require__(/*! ../util/lint */ \"./util/lint.js\"), Parser = __webpack_require__(/*! .. */ \"./index.js\"), Token = __webpack_require__(/*! . */ \"./src/index.js\");\nclass HtmlToken extends Token {\n  constructor(name, attr, closing, selfClosing, config = Parser.getConfig(), accum = []) {\n    super(void 0, config, true, accum);\n    __publicField(this, \"type\", \"html\");\n    __privateAdd(this, _closing, void 0);\n    __privateAdd(this, _selfClosing, void 0);\n    __privateAdd(this, _tag, void 0);\n    this.insertAt(attr);\n    this.setAttribute(\"name\", name.toLowerCase());\n    __privateSet(this, _closing, closing);\n    __privateSet(this, _selfClosing, selfClosing);\n    __privateSet(this, _tag, name);\n  }\n  get closing() {\n    return __privateGet(this, _closing);\n  }\n  toString() {\n    return `<${__privateGet(this, _closing) ? \"/\" : \"\"}${__privateGet(this, _tag)}${super.toString()}${__privateGet(this, _selfClosing) ? \"/\" : \"\"}>`;\n  }\n  getPadding() {\n    return __privateGet(this, _tag).length + (__privateGet(this, _closing) ? 2 : 1);\n  }\n  print() {\n    return super.print({\n      pre: `&lt;${__privateGet(this, _closing) ? \"/\" : \"\"}${__privateGet(this, _tag)}`,\n      post: `${__privateGet(this, _selfClosing) ? \"/\" : \"\"}&gt;`\n    });\n  }\n  lint(start = 0) {\n    const errors = super.lint(start);\n    let refError;\n    if (this.name === \"h1\" && !__privateGet(this, _closing)) {\n      refError = generateForSelf(this, this.getRootNode().posFromIndex(start), \"<h1>\");\n      errors.push(refError);\n    }\n    try {\n      this.findMatchingTag();\n    } catch ({ message: errorMsg }) {\n      const [message] = errorMsg.split(\"\\uFF1A\");\n      refError || (refError = generateForSelf(this, this.getRootNode().posFromIndex(start), \"\"));\n      errors.push({ ...refError, message, severity: message === \"\\u672A\\u95ED\\u5408\\u7684\\u6807\\u7B7E\" ? \"warning\" : \"error\" });\n    }\n    return errors;\n  }\n  findMatchingTag() {\n    const { html } = this.getAttribute(\"config\"), { name: tagName, parentNode } = this, string = String(this);\n    if (__privateGet(this, _closing) && __privateGet(this, _selfClosing)) {\n      throw new SyntaxError(`\\u540C\\u65F6\\u95ED\\u5408\\u548C\\u81EA\\u5C01\\u95ED\\u7684\\u6807\\u7B7E\\uFF1A${string}`);\n    } else if (html[2].includes(tagName) || __privateGet(this, _selfClosing) && html[1].includes(tagName)) {\n      return this;\n    } else if (__privateGet(this, _selfClosing) && html[0].includes(tagName)) {\n      throw new SyntaxError(`\\u65E0\\u6548\\u81EA\\u5C01\\u95ED\\u6807\\u7B7E\\uFF1A${string}`);\n    } else if (!parentNode) {\n      return void 0;\n    }\n    const { childNodes } = parentNode, i = childNodes.indexOf(this), siblings = __privateGet(this, _closing) ? childNodes.slice(0, i).reverse().filter(({ type, name }) => type === \"html\" && name === tagName) : childNodes.slice(i + 1).filter(({ type, name }) => type === \"html\" && name === tagName);\n    let imbalance = __privateGet(this, _closing) ? -1 : 1;\n    for (const token of siblings) {\n      if (token.closing) {\n        imbalance--;\n      } else {\n        imbalance++;\n      }\n      if (imbalance === 0) {\n        return token;\n      }\n    }\n    throw new SyntaxError(`\\u672A${__privateGet(this, _closing) ? \"\\u5339\\u914D\\u7684\\u95ED\\u5408\" : \"\\u95ED\\u5408\\u7684\"}\\u6807\\u7B7E\\uFF1A${string}`);\n  }\n}\n_closing = new WeakMap();\n_selfClosing = new WeakMap();\n_tag = new WeakMap();\nmodule.exports = HtmlToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/html.js?");

/***/ }),

/***/ "./src/imageParameter.js":
/*!*******************************!*\
  !*** ./src/imageParameter.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\nvar _validate, validate_fn, _syntax;\nconst { print, extUrlChar } = __webpack_require__(/*! ../util/string */ \"./util/string.js\"), Parser = __webpack_require__(/*! .. */ \"./index.js\"), Token = __webpack_require__(/*! . */ \"./src/index.js\");\nconst _ImageParameterToken = class extends Token {\n  constructor(str, config = Parser.getConfig(), accum = []) {\n    var __super = (...args) => {\n      super(...args);\n      __publicField(this, \"type\", \"image-parameter\");\n      __privateAdd(this, _syntax, \"\");\n    };\n    var _a;\n    const regexes = Object.entries(config.img).map(\n      ([syntax, param2]) => [syntax, param2, new RegExp(`^(\\\\s*)${syntax.replace(\"$1\", \"(.*)\")}(\\\\s*)$`, \"u\")]\n    ), param = regexes.find(([, , regex]) => regex.test(str));\n    if (param) {\n      const mt = param[2].exec(str);\n      if (mt.length !== 4 || __privateMethod(_a = _ImageParameterToken, _validate, validate_fn).call(_a, param[1], mt[2], config, true)) {\n        if (mt.length === 3) {\n          __super(void 0, config, true, accum);\n          __privateSet(this, _syntax, str);\n        } else {\n          __super(mt[2], config, true, accum);\n          __privateSet(this, _syntax, `${mt[1]}${param[0]}${mt[3]}`);\n        }\n        this.setAttribute(\"name\", param[1]).setAttribute(\"stage\", Parser.MAX_STAGE);\n        return;\n      }\n    }\n    __super(str, config, true, accum);\n    this.setAttribute(\"name\", \"caption\").setAttribute(\"stage\", 7);\n  }\n  isPlain() {\n    return true;\n  }\n  toString() {\n    return __privateGet(this, _syntax) ? __privateGet(this, _syntax).replace(\"$1\", super.toString()) : super.toString();\n  }\n  getPadding() {\n    return Math.max(0, __privateGet(this, _syntax).indexOf(\"$1\"));\n  }\n  print() {\n    return __privateGet(this, _syntax) ? `<span class=\"wpb-image-parameter\">${__privateGet(this, _syntax).replace(\"$1\", print(this.childNodes))}</span>` : super.print({ class: \"image-caption\" });\n  }\n};\nlet ImageParameterToken = _ImageParameterToken;\n_validate = new WeakSet();\nvalidate_fn = function(key, value, config = Parser.getConfig()) {\n  value = value.replaceAll(/\\0\\d+t\\x7F/gu, \"\").trim();\n  if (key === \"width\") {\n    return /^\\d*(?:x\\d*)?$/u.test(value);\n  } else if ([\"alt\", \"class\", \"manualthumb\", \"frameless\", \"framed\", \"thumbnail\"].includes(key)) {\n    return true;\n  } else if (key === \"link\") {\n    if (!value) {\n      return true;\n    }\n    const regex = new RegExp(`(?:${config.protocol}|//)${extUrlChar}(?=\\0\\\\d+t\\x7F|$)`, \"iu\");\n    if (regex.test(value)) {\n      return true;\n    } else if (value.startsWith(\"[[\") && value.endsWith(\"]]\")) {\n      value = value.slice(2, -2);\n    }\n    if (value.includes(\"%\")) {\n      try {\n        value = decodeURIComponent(value);\n      } catch (e) {\n      }\n    }\n    const { valid } = Parser.normalizeTitle(value, 0, config, true);\n    return valid;\n  }\n  return !isNaN(value);\n};\n_syntax = new WeakMap();\n__privateAdd(ImageParameterToken, _validate);\nmodule.exports = ImageParameterToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/imageParameter.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateWrapper = (obj, member, setter, getter) => ({\n  set _(value) {\n    __privateSet(obj, member, value, setter);\n  },\n  get _() {\n    return __privateGet(obj, member, getter);\n  }\n});\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\nvar _stage, _config, _accum, _parseOnce, _buildFromStr, _build, _parseCommentAndExt, parseCommentAndExt_fn, _parseBrackets, parseBrackets_fn, _parseHtml, parseHtml_fn, _parseTable, parseTable_fn, _parseHrAndDoubleUndescore, parseHrAndDoubleUndescore_fn, _parseLinks, parseLinks_fn, _parseQuotes, parseQuotes_fn, _parseExternalLinks, parseExternalLinks_fn, _parseMagicLinks, parseMagicLinks_fn, _parseList, parseList_fn, _parseConverter, parseConverter_fn;\nconst Parser = __webpack_require__(/*! .. */ \"./index.js\"), AstElement = __webpack_require__(/*! ../lib/element */ \"./lib/element.js\"), AstText = __webpack_require__(/*! ../lib/text */ \"./lib/text.js\");\nconst { MAX_STAGE } = Parser;\nconst _Token = class extends AstElement {\n  constructor(wikitext, config = Parser.getConfig(), halfParsed = false, accum = []) {\n    super();\n    __privateAdd(this, _parseCommentAndExt);\n    __privateAdd(this, _parseBrackets);\n    __privateAdd(this, _parseHtml);\n    __privateAdd(this, _parseTable);\n    __privateAdd(this, _parseHrAndDoubleUndescore);\n    __privateAdd(this, _parseLinks);\n    __privateAdd(this, _parseQuotes);\n    __privateAdd(this, _parseExternalLinks);\n    __privateAdd(this, _parseMagicLinks);\n    __privateAdd(this, _parseList);\n    __privateAdd(this, _parseConverter);\n    __publicField(this, \"type\", \"root\");\n    __privateAdd(this, _stage, 0);\n    __privateAdd(this, _config, void 0);\n    __privateAdd(this, _accum, void 0);\n    __privateAdd(this, _parseOnce, (n = __privateGet(this, _stage), include = false) => {\n      if (n < __privateGet(this, _stage) || !this.isPlain() || this.childNodes.length === 0) {\n        return this;\n      }\n      switch (n) {\n        case 0:\n          if (this.type === \"root\") {\n            __privateGet(this, _accum).shift();\n          }\n          __privateMethod(this, _parseCommentAndExt, parseCommentAndExt_fn).call(this, include);\n          break;\n        case 1:\n          __privateMethod(this, _parseBrackets, parseBrackets_fn).call(this);\n          break;\n        case 2:\n          __privateMethod(this, _parseHtml, parseHtml_fn).call(this);\n          break;\n        case 3:\n          __privateMethod(this, _parseTable, parseTable_fn).call(this);\n          break;\n        case 4:\n          __privateMethod(this, _parseHrAndDoubleUndescore, parseHrAndDoubleUndescore_fn).call(this);\n          break;\n        case 5:\n          __privateMethod(this, _parseLinks, parseLinks_fn).call(this);\n          break;\n        case 6:\n          __privateMethod(this, _parseQuotes, parseQuotes_fn).call(this);\n          break;\n        case 7:\n          __privateMethod(this, _parseExternalLinks, parseExternalLinks_fn).call(this);\n          break;\n        case 8:\n          __privateMethod(this, _parseMagicLinks, parseMagicLinks_fn).call(this);\n          break;\n        case 9:\n          __privateMethod(this, _parseList, parseList_fn).call(this);\n          break;\n        case 10:\n          __privateMethod(this, _parseConverter, parseConverter_fn).call(this);\n      }\n      if (this.type === \"root\") {\n        for (const token of __privateGet(this, _accum)) {\n          token.getAttribute(\"parseOnce\")(n, include);\n        }\n      }\n      __privateWrapper(this, _stage)._++;\n      return this;\n    });\n    __privateAdd(this, _buildFromStr, (str) => str.split(/[\\0\\x7F]/u).map(\n      (s, i) => i % 2 === 0 ? new AstText(s) : __privateGet(this, _accum)[Number(s.slice(0, -1))]\n    ));\n    __privateAdd(this, _build, () => {\n      __privateSet(this, _stage, MAX_STAGE);\n      const { length, firstChild } = this, str = String(firstChild);\n      if (length === 1 && firstChild.type === \"text\" && str.includes(\"\\0\")) {\n        this.replaceChildren(...__privateGet(this, _buildFromStr).call(this, str));\n        this.normalize();\n        if (this.type === \"root\") {\n          for (const token of __privateGet(this, _accum)) {\n            token.getAttribute(\"build\")();\n          }\n        }\n      }\n    });\n    if (typeof wikitext === \"string\") {\n      this.insertAt(halfParsed ? wikitext : wikitext.replaceAll(/[\\0\\x7F]/gu, \"\"));\n    }\n    __privateSet(this, _config, config);\n    __privateSet(this, _accum, accum);\n    accum.push(this);\n  }\n  getAttribute(key) {\n    switch (key) {\n      case \"config\":\n        return JSON.parse(JSON.stringify(__privateGet(this, _config)));\n      case \"accum\":\n        return __privateGet(this, _accum);\n      case \"parseOnce\":\n        return __privateGet(this, _parseOnce);\n      case \"buildFromStr\":\n        return __privateGet(this, _buildFromStr);\n      case \"build\":\n        return __privateGet(this, _build);\n      default:\n        return super.getAttribute(key);\n    }\n  }\n  setAttribute(key, value) {\n    switch (key) {\n      case \"stage\":\n        if (__privateGet(this, _stage) === 0 && this.type === \"root\") {\n          __privateGet(this, _accum).shift();\n        }\n        __privateSet(this, _stage, value);\n        return this;\n      default:\n        return super.setAttribute(key, value);\n    }\n  }\n  isPlain() {\n    return this.constructor === _Token;\n  }\n  insertAt(token, i = this.childNodes.length) {\n    if (typeof token === \"string\") {\n      token = new AstText(token);\n    }\n    super.insertAt(token, i);\n    if (token.type === \"root\") {\n      token.type = \"plain\";\n    }\n    return token;\n  }\n  normalizeTitle(title, defaultNs = 0, halfParsed = false) {\n    return Parser.normalizeTitle(title, defaultNs, __privateGet(this, _config), halfParsed);\n  }\n  afterBuild() {\n    if (this.type === \"root\") {\n      for (const token of __privateGet(this, _accum)) {\n        token.afterBuild();\n      }\n    }\n    return this;\n  }\n  parse(n = MAX_STAGE, include = false) {\n    while (__privateGet(this, _stage) < n) {\n      __privateGet(this, _parseOnce).call(this, __privateGet(this, _stage), include);\n    }\n    if (n) {\n      __privateGet(this, _build).call(this);\n      this.afterBuild();\n    }\n    return this;\n  }\n};\nlet Token = _Token;\n_stage = new WeakMap();\n_config = new WeakMap();\n_accum = new WeakMap();\n_parseOnce = new WeakMap();\n_buildFromStr = new WeakMap();\n_build = new WeakMap();\n_parseCommentAndExt = new WeakSet();\nparseCommentAndExt_fn = function(includeOnly) {\n  const parseCommentAndExt = __webpack_require__(/*! ../parser/commentAndExt */ \"./parser/commentAndExt.js\");\n  this.setText(parseCommentAndExt(String(this), __privateGet(this, _config), __privateGet(this, _accum), includeOnly));\n};\n_parseBrackets = new WeakSet();\nparseBrackets_fn = function() {\n  const parseBrackets = __webpack_require__(/*! ../parser/brackets */ \"./parser/brackets.js\");\n  const str = this.type === \"root\" ? String(this) : `\\0${String(this)}`, parsed = parseBrackets(str, __privateGet(this, _config), __privateGet(this, _accum));\n  this.setText(this.type === \"root\" ? parsed : parsed.slice(1));\n};\n_parseHtml = new WeakSet();\nparseHtml_fn = function() {\n  const parseHtml = __webpack_require__(/*! ../parser/html */ \"./parser/html.js\");\n  this.setText(parseHtml(String(this), __privateGet(this, _config), __privateGet(this, _accum)));\n};\n_parseTable = new WeakSet();\nparseTable_fn = function() {\n  const parseTable = __webpack_require__(/*! ../parser/table */ \"./parser/table.js\"), TableToken = __webpack_require__(/*! ./table */ \"./src/table/index.js\");\n  this.setText(parseTable(this, __privateGet(this, _config), __privateGet(this, _accum)));\n  for (const table of __privateGet(this, _accum)) {\n    if (table instanceof TableToken && table.type !== \"td\") {\n      table.normalize();\n      const { childNodes: [, child] } = table;\n      if (typeof child === \"string\" && child.includes(\"\\0\")) {\n        table.removeAt(1);\n        const inner = new _Token(child, __privateGet(this, _config), true, __privateGet(this, _accum));\n        table.insertAt(inner, 1);\n        inner.setAttribute(\"stage\", 4);\n      }\n    }\n  }\n};\n_parseHrAndDoubleUndescore = new WeakSet();\nparseHrAndDoubleUndescore_fn = function() {\n  const parseHrAndDoubleUnderscore = __webpack_require__(/*! ../parser/hrAndDoubleUnderscore */ \"./parser/hrAndDoubleUnderscore.js\");\n  this.setText(parseHrAndDoubleUnderscore(this, __privateGet(this, _config), __privateGet(this, _accum)));\n};\n_parseLinks = new WeakSet();\nparseLinks_fn = function() {\n  const parseLinks = __webpack_require__(/*! ../parser/links */ \"./parser/links.js\");\n  this.setText(parseLinks(String(this), __privateGet(this, _config), __privateGet(this, _accum)));\n};\n_parseQuotes = new WeakSet();\nparseQuotes_fn = function() {\n  const parseQuotes = __webpack_require__(/*! ../parser/quotes */ \"./parser/quotes.js\");\n  const lines = String(this).split(\"\\n\");\n  for (let i = 0; i < lines.length; i++) {\n    lines[i] = parseQuotes(lines[i], __privateGet(this, _config), __privateGet(this, _accum));\n  }\n  this.setText(lines.join(\"\\n\"));\n};\n_parseExternalLinks = new WeakSet();\nparseExternalLinks_fn = function() {\n  const parseExternalLinks = __webpack_require__(/*! ../parser/externalLinks */ \"./parser/externalLinks.js\");\n  this.setText(parseExternalLinks(String(this), __privateGet(this, _config), __privateGet(this, _accum)));\n};\n_parseMagicLinks = new WeakSet();\nparseMagicLinks_fn = function() {\n  const parseMagicLinks = __webpack_require__(/*! ../parser/magicLinks */ \"./parser/magicLinks.js\");\n  this.setText(parseMagicLinks(String(this), __privateGet(this, _config), __privateGet(this, _accum)));\n};\n_parseList = new WeakSet();\nparseList_fn = function() {\n  if (this.type === \"image-parameter\") {\n    return;\n  }\n  const parseList = __webpack_require__(/*! ../parser/list */ \"./parser/list.js\");\n  const lines = String(this).split(\"\\n\");\n  let i = this.type === \"root\" || this.type === \"ext-inner\" && this.type === \"poem\" ? 0 : 1;\n  for (; i < lines.length; i++) {\n    lines[i] = parseList(lines[i], __privateGet(this, _config), __privateGet(this, _accum));\n  }\n  this.setText(lines.join(\"\\n\"));\n};\n_parseConverter = new WeakSet();\nparseConverter_fn = function() {\n  const parseConverter = __webpack_require__(/*! ../parser/converter */ \"./parser/converter.js\");\n  this.setText(parseConverter(String(this), __privateGet(this, _config), __privateGet(this, _accum)));\n};\nmodule.exports = Token;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/index.js?");

/***/ }),

/***/ "./src/inputbox.js":
/*!*************************!*\
  !*** ./src/inputbox.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst parseBrackets = __webpack_require__(/*! ../parser/brackets */ \"./parser/brackets.js\"), Parser = __webpack_require__(/*! .. */ \"./index.js\"), Token = __webpack_require__(/*! . */ \"./src/index.js\");\nclass InputboxToken extends Token {\n  constructor(wikitext, config = Parser.getConfig(), accum = []) {\n    wikitext = parseBrackets(wikitext, config, accum).replaceAll(\n      /\\0(\\d+)(\\D)\\x7F/gu,\n      (_, num, mark) => `\\0${Number(num) + 1}${mark}\\x7F`\n    );\n    super(wikitext, config, true, accum);\n    __publicField(this, \"type\", \"ext-inner\");\n    __publicField(this, \"name\", \"inputbox\");\n  }\n  afterBuild() {\n    for (const heading of this.querySelectorAll(\"heading\")) {\n      heading.replaceWith(String(heading));\n    }\n  }\n}\nmodule.exports = InputboxToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/inputbox.js?");

/***/ }),

/***/ "./src/link/category.js":
/*!******************************!*\
  !*** ./src/link/category.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst LinkToken = __webpack_require__(/*! . */ \"./src/link/index.js\");\nclass CategoryToken extends LinkToken {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"type\", \"category\");\n  }\n}\nmodule.exports = CategoryToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/link/category.js?");

/***/ }),

/***/ "./src/link/file.js":
/*!**************************!*\
  !*** ./src/link/file.js ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst { explode } = __webpack_require__(/*! ../../util/string */ \"./util/string.js\"), { generateForChild } = __webpack_require__(/*! ../../util/lint */ \"./util/lint.js\"), Parser = __webpack_require__(/*! ../.. */ \"./index.js\"), LinkToken = __webpack_require__(/*! . */ \"./src/link/index.js\"), ImageParameterToken = __webpack_require__(/*! ../imageParameter */ \"./src/imageParameter.js\");\nclass FileToken extends LinkToken {\n  constructor(link, text, config = Parser.getConfig(), accum = []) {\n    super(link, void 0, config, accum);\n    __publicField(this, \"type\", \"file\");\n    this.append(...explode(\"-{\", \"}-\", \"|\", text).map((part) => new ImageParameterToken(part, config, accum)));\n  }\n  lint(start = 0) {\n    const errors = super.lint(start), frameArgs = this.getFrameArgs(), captions = this.getArgs(\"caption\");\n    if (frameArgs.length > 1 || captions.size > 1) {\n      const rect = this.getRootNode().posFromIndex(start);\n      if (frameArgs.length > 1) {\n        errors.push(...frameArgs.map((arg) => generateForChild(arg, rect, \"\\u91CD\\u590D\\u6216\\u51B2\\u7A81\\u7684\\u56FE\\u7247\\u6846\\u67B6\\u53C2\\u6570\")));\n      }\n      if (captions.size > 1) {\n        errors.push(...[...captions].map((arg) => generateForChild(arg, rect, \"\\u91CD\\u590D\\u7684\\u56FE\\u7247\\u8BF4\\u660E\")));\n      }\n    }\n    return errors;\n  }\n  getAllArgs() {\n    return this.childNodes.slice(1);\n  }\n  getFrameArgs() {\n    return this.getAllArgs().filter(({ name }) => [\"manualthumb\", \"frameless\", \"framed\", \"thumbnail\"].includes(name));\n  }\n  getArgs(key) {\n    return new Set(this.getAllArgs().filter(({ name }) => key === name));\n  }\n}\nmodule.exports = FileToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/link/file.js?");

/***/ }),

/***/ "./src/link/galleryImage.js":
/*!**********************************!*\
  !*** ./src/link/galleryImage.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst Parser = __webpack_require__(/*! ../.. */ \"./index.js\"), FileToken = __webpack_require__(/*! ./file */ \"./src/link/file.js\");\nclass GalleryImageToken extends FileToken {\n  constructor(link, text, config = Parser.getConfig(), accum = []) {\n    let token;\n    if (text !== void 0) {\n      const Token = __webpack_require__(/*! .. */ \"./src/index.js\");\n      token = new Token(text, config, true, accum);\n      token.type = \"temp\";\n      for (let n = 1; n < Parser.MAX_STAGE; n++) {\n        token.getAttribute(\"parseOnce\")();\n      }\n      accum.splice(accum.indexOf(token), 1);\n    }\n    const newConfig = JSON.parse(JSON.stringify(config));\n    for (const [k, v] of Object.entries(newConfig.img)) {\n      if (v === \"width\") {\n        delete newConfig.img[k];\n      }\n    }\n    super(link, token == null ? void 0 : token.toString(), newConfig, accum);\n    __publicField(this, \"type\", \"gallery-image\");\n    this.setAttribute(\"bracket\", false);\n  }\n  getPadding() {\n    return 0;\n  }\n}\nmodule.exports = GalleryImageToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/link/galleryImage.js?");

/***/ }),

/***/ "./src/link/index.js":
/*!***************************!*\
  !*** ./src/link/index.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _bracket;\nconst Parser = __webpack_require__(/*! ../.. */ \"./index.js\"), Token = __webpack_require__(/*! .. */ \"./src/index.js\");\nclass LinkToken extends Token {\n  constructor(link, linkText, config = Parser.getConfig(), accum = []) {\n    super(void 0, config, true, accum);\n    __publicField(this, \"type\", \"link\");\n    __privateAdd(this, _bracket, true);\n    const AtomToken = __webpack_require__(/*! ../atom */ \"./src/atom/index.js\");\n    this.insertAt(new AtomToken(link, \"link-target\", config, accum));\n    if (linkText !== void 0) {\n      const inner = new Token(linkText, config, true, accum);\n      inner.type = \"link-text\";\n      this.insertAt(inner.setAttribute(\"stage\", Parser.MAX_STAGE - 1));\n    }\n  }\n  setAttribute(key, value) {\n    if (key === \"bracket\") {\n      __privateSet(this, _bracket, Boolean(value));\n      return this;\n    }\n    return super.setAttribute(key, value);\n  }\n  toString() {\n    const str = super.toString(\"|\");\n    return __privateGet(this, _bracket) ? `[[${str}]]` : str;\n  }\n  getPadding() {\n    return 2;\n  }\n  getGaps() {\n    return 1;\n  }\n  print() {\n    return super.print(__privateGet(this, _bracket) ? { pre: \"[[\", post: \"]]\", sep: \"|\" } : { sep: \"|\" });\n  }\n}\n_bracket = new WeakMap();\nmodule.exports = LinkToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/link/index.js?");

/***/ }),

/***/ "./src/magicLink.js":
/*!**************************!*\
  !*** ./src/magicLink.js ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst { generateForChild } = __webpack_require__(/*! ../util/lint */ \"./util/lint.js\"), Parser = __webpack_require__(/*! .. */ \"./index.js\"), Token = __webpack_require__(/*! . */ \"./src/index.js\");\nclass MagicLinkToken extends Token {\n  constructor(url, doubleSlash, config = Parser.getConfig(), accum = []) {\n    super(url, config, true, accum);\n    __publicField(this, \"type\", \"free-ext-link\");\n    if (doubleSlash) {\n      this.type = \"ext-link-url\";\n    }\n  }\n  lint(start = 0) {\n    const errors = super.lint(start);\n    let rect;\n    for (const child of this.childNodes) {\n      const str = String(child);\n      if (child.type !== \"text\" || !/[，；。：！？（）【】]/u.test(str)) {\n        continue;\n      }\n      rect || (rect = this.getRootNode().posFromIndex(start));\n      const refError = generateForChild(child, rect, \"URL\\u4E2D\\u7684\\u5168\\u89D2\\u6807\\u70B9\", \"warning\");\n      errors.push(...[...str.matchAll(/[，；。：！？（）【】]/gu)].map(({ index }) => {\n        const lines = str.slice(0, index).split(\"\\n\"), { length: top } = lines, { length: left } = lines.at(-1), startLine = refError.startLine + top - 1, startCol = top > 1 ? left : refError.startCol + left;\n        return { ...refError, startLine, endLine: startLine, startCol, endCol: startCol + 1 };\n      }));\n    }\n    return errors;\n  }\n}\nmodule.exports = MagicLinkToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/magicLink.js?");

/***/ }),

/***/ "./src/nested/choose.js":
/*!******************************!*\
  !*** ./src/nested/choose.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst Parser = __webpack_require__(/*! ../.. */ \"./index.js\"), NestedToken = __webpack_require__(/*! . */ \"./src/nested/index.js\");\nclass ChooseToken extends NestedToken {\n  constructor(wikitext, config = Parser.getConfig(), accum = []) {\n    const regex = /<(option|choicetemplate)(\\s[^>]*)?>(.*?)<\\/(\\1)>/gsu;\n    super(wikitext, regex, config, accum);\n    __publicField(this, \"name\", \"choose\");\n  }\n}\nmodule.exports = ChooseToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/nested/choose.js?");

/***/ }),

/***/ "./src/nested/combobox.js":
/*!********************************!*\
  !*** ./src/nested/combobox.js ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst Parser = __webpack_require__(/*! ../.. */ \"./index.js\"), NestedToken = __webpack_require__(/*! . */ \"./src/nested/index.js\");\nclass ComboboxToken extends NestedToken {\n  constructor(wikitext, config = Parser.getConfig(), accum = []) {\n    super(wikitext, /<(combooption)(\\s[^>]*)?>(.*?)<\\/(combooption\\s*)>/gisu, config, accum);\n    __publicField(this, \"name\", \"combobox\");\n  }\n}\nmodule.exports = ComboboxToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/nested/combobox.js?");

/***/ }),

/***/ "./src/nested/index.js":
/*!*****************************!*\
  !*** ./src/nested/index.js ***!
  \*****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst { generateForChild } = __webpack_require__(/*! ../../util/lint */ \"./util/lint.js\"), Parser = __webpack_require__(/*! ../.. */ \"./index.js\"), Token = __webpack_require__(/*! .. */ \"./src/index.js\");\nclass NestedToken extends Token {\n  constructor(wikitext, regex, config = Parser.getConfig(), accum = []) {\n    var _a;\n    const ExtToken = __webpack_require__(/*! ../tagPair/ext */ \"./src/tagPair/ext.js\"), NoincludeToken = __webpack_require__(/*! ../nowiki/noinclude */ \"./src/nowiki/noinclude.js\");\n    const text = (_a = wikitext == null ? void 0 : wikitext.replaceAll(\n      regex,\n      (_, name, attr, inner, closing) => {\n        const str = `\\0${accum.length + 1}e\\x7F`;\n        new ExtToken(name, attr, inner, closing, config, accum);\n        return str;\n      }\n    )) == null ? void 0 : _a.replaceAll(/(^|\\0\\d+e\\x7F)(.*?)(?=$|\\0\\d+e\\x7F)/gsu, (_, lead, substr) => {\n      if (substr === \"\") {\n        return lead;\n      }\n      new NoincludeToken(substr, config, accum);\n      return `${lead}\\0${accum.length}c\\x7F`;\n    });\n    super(text, config, true, accum);\n    __publicField(this, \"type\", \"ext-inner\");\n  }\n  lint(start = 0) {\n    let rect;\n    return [\n      ...super.lint(start),\n      ...this.childNodes.filter((child) => {\n        if (child.type === \"ext\") {\n          return false;\n        }\n        const str = String(child).trim();\n        return str && !/^<!--.*-->$/u.test(str);\n      }).map((child) => {\n        rect || (rect = this.getRootNode().posFromIndex(start));\n        return generateForChild(child, rect, `<${this.name}>\\u5185\\u7684\\u65E0\\u6548\\u5185\\u5BB9`);\n      })\n    ];\n  }\n}\nmodule.exports = NestedToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/nested/index.js?");

/***/ }),

/***/ "./src/nested/references.js":
/*!**********************************!*\
  !*** ./src/nested/references.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst Parser = __webpack_require__(/*! ../.. */ \"./index.js\"), NestedToken = __webpack_require__(/*! . */ \"./src/nested/index.js\");\nclass ReferencesToken extends NestedToken {\n  constructor(wikitext, config = Parser.getConfig(), accum = []) {\n    super(wikitext, /<(ref)(\\s[^>]*)?>(.*?)<\\/(ref\\s*)>/gisu, config, accum);\n    __publicField(this, \"name\", \"references\");\n  }\n}\nmodule.exports = ReferencesToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/nested/references.js?");

/***/ }),

/***/ "./src/nowiki/comment.js":
/*!*******************************!*\
  !*** ./src/nowiki/comment.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst { generateForSelf } = __webpack_require__(/*! ../../util/lint */ \"./util/lint.js\"), hidden = __webpack_require__(/*! ../../mixin/hidden */ \"./mixin/hidden.js\"), Parser = __webpack_require__(/*! ../.. */ \"./index.js\"), NowikiToken = __webpack_require__(/*! . */ \"./src/nowiki/index.js\");\nclass CommentToken extends hidden(NowikiToken) {\n  constructor(wikitext, closed = true, config = Parser.getConfig(), accum = []) {\n    super(wikitext, config, accum);\n    __publicField(this, \"type\", \"comment\");\n    __publicField(this, \"closed\");\n    this.closed = closed;\n  }\n  toString() {\n    return `<!--${String(this.firstChild)}${this.closed ? \"-->\" : \"\"}`;\n  }\n  getPadding() {\n    return 4;\n  }\n  print() {\n    return super.print({ pre: \"&lt;!--\", post: this.closed ? \"--&gt;\" : \"\" });\n  }\n  lint(start = 0) {\n    return this.closed ? [] : [generateForSelf(this, this.getRootNode().posFromIndex(start), \"\\u672A\\u95ED\\u5408\\u7684HTML\\u6CE8\\u91CA\")];\n  }\n}\nmodule.exports = CommentToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/nowiki/comment.js?");

/***/ }),

/***/ "./src/nowiki/dd.js":
/*!**************************!*\
  !*** ./src/nowiki/dd.js ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst NowikiToken = __webpack_require__(/*! . */ \"./src/nowiki/index.js\");\nclass DdToken extends NowikiToken {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"type\", \"dd\");\n  }\n}\nmodule.exports = DdToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/nowiki/dd.js?");

/***/ }),

/***/ "./src/nowiki/doubleUnderscore.js":
/*!****************************************!*\
  !*** ./src/nowiki/doubleUnderscore.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst hidden = __webpack_require__(/*! ../../mixin/hidden */ \"./mixin/hidden.js\"), NowikiToken = __webpack_require__(/*! . */ \"./src/nowiki/index.js\");\nclass DoubleUnderscoreToken extends hidden(NowikiToken) {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"type\", \"double-underscore\");\n  }\n  toString() {\n    return `__${String(this.firstChild)}__`;\n  }\n  getPadding() {\n    return 2;\n  }\n  print() {\n    return super.print({ pre: \"__\", post: \"__\" });\n  }\n}\nmodule.exports = DoubleUnderscoreToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/nowiki/doubleUnderscore.js?");

/***/ }),

/***/ "./src/nowiki/hr.js":
/*!**************************!*\
  !*** ./src/nowiki/hr.js ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst Parser = __webpack_require__(/*! ../.. */ \"./index.js\"), NowikiToken = __webpack_require__(/*! . */ \"./src/nowiki/index.js\");\nclass HrToken extends NowikiToken {\n  constructor(n, config = Parser.getConfig(), accum = []) {\n    super(\"-\".repeat(n), config, accum);\n    __publicField(this, \"type\", \"hr\");\n  }\n}\nmodule.exports = HrToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/nowiki/hr.js?");

/***/ }),

/***/ "./src/nowiki/index.js":
/*!*****************************!*\
  !*** ./src/nowiki/index.js ***!
  \*****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst { generateForSelf } = __webpack_require__(/*! ../../util/lint */ \"./util/lint.js\"), Parser = __webpack_require__(/*! ../.. */ \"./index.js\"), Token = __webpack_require__(/*! .. */ \"./src/index.js\");\nclass NowikiToken extends Token {\n  constructor(wikitext, config = Parser.getConfig(), accum = []) {\n    super(wikitext, config, true, accum);\n    __publicField(this, \"type\", \"ext-inner\");\n  }\n  lint(start = 0) {\n    const { type, name } = this;\n    return type === \"ext-inner\" && (name === \"templatestyles\" || name === \"section\") ? [generateForSelf(this, this.getRootNode().posFromIndex(start), `<${name}>\\u6807\\u7B7E\\u5185\\u4E0D\\u5E94\\u6709\\u4EFB\\u4F55\\u5185\\u5BB9`)] : super.lint(start);\n  }\n}\nmodule.exports = NowikiToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/nowiki/index.js?");

/***/ }),

/***/ "./src/nowiki/list.js":
/*!****************************!*\
  !*** ./src/nowiki/list.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst DdToken = __webpack_require__(/*! ./dd */ \"./src/nowiki/dd.js\");\nclass ListToken extends DdToken {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"type\", \"list\");\n  }\n}\nmodule.exports = ListToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/nowiki/list.js?");

/***/ }),

/***/ "./src/nowiki/noinclude.js":
/*!*********************************!*\
  !*** ./src/nowiki/noinclude.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst hidden = __webpack_require__(/*! ../../mixin/hidden */ \"./mixin/hidden.js\"), NowikiToken = __webpack_require__(/*! . */ \"./src/nowiki/index.js\");\nclass NoincludeToken extends hidden(NowikiToken) {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"type\", \"noinclude\");\n  }\n}\nmodule.exports = NoincludeToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/nowiki/noinclude.js?");

/***/ }),

/***/ "./src/nowiki/quote.js":
/*!*****************************!*\
  !*** ./src/nowiki/quote.js ***!
  \*****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst { generateForSelf } = __webpack_require__(/*! ../../util/lint */ \"./util/lint.js\"), Parser = __webpack_require__(/*! ../.. */ \"./index.js\"), AstText = __webpack_require__(/*! ../../lib/text */ \"./lib/text.js\"), NowikiToken = __webpack_require__(/*! . */ \"./src/nowiki/index.js\");\nclass QuoteToken extends NowikiToken {\n  constructor(n, config = Parser.getConfig(), accum = []) {\n    super(\"'\".repeat(n), config, accum);\n    __publicField(this, \"type\", \"quote\");\n  }\n  lint(start = 0) {\n    const { previousSibling, nextSibling } = this, message = `\\u5B64\\u7ACB\\u7684\"'\"`, errors = [];\n    let refError;\n    if ((previousSibling == null ? void 0 : previousSibling.type) === \"text\" && previousSibling.data.at(-1) === \"'\") {\n      refError = generateForSelf(this, this.getRootNode().posFromIndex(start), \"\");\n      const { startLine, startCol } = refError, [, { length }] = previousSibling.data.match(/(?:^|[^'])('+)$/u);\n      errors.push({ message, startLine, startCol: startCol - length, endLine: startLine, endCol: startCol });\n    }\n    if ((nextSibling == null ? void 0 : nextSibling.type) === \"text\" && nextSibling.data[0] === \"'\") {\n      refError || (refError = generateForSelf(this, this.getRootNode().posFromIndex(start), \"\"));\n      const { endLine, endCol } = refError, [{ length }] = nextSibling.data.match(/^'+/u);\n      errors.push({ message, startLine: endLine, startCol: endCol, endLine, endCol: endCol + length });\n    }\n    return errors;\n  }\n}\nmodule.exports = QuoteToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/nowiki/quote.js?");

/***/ }),

/***/ "./src/onlyinclude.js":
/*!****************************!*\
  !*** ./src/onlyinclude.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst Parser = __webpack_require__(/*! .. */ \"./index.js\"), Token = __webpack_require__(/*! . */ \"./src/index.js\");\nclass OnlyincludeToken extends Token {\n  constructor(inner, config = Parser.getConfig(), accum = []) {\n    super(inner, config, true, accum);\n    __publicField(this, \"type\", \"onlyinclude\");\n  }\n  toString() {\n    return `<onlyinclude>${super.toString()}</onlyinclude>`;\n  }\n  getPadding() {\n    return 13;\n  }\n  print() {\n    return super.print({ pre: \"&lt;onlyinclude&gt;\", post: \"&lt;/onlyinclude&gt;\" });\n  }\n  isPlain() {\n    return true;\n  }\n}\nmodule.exports = OnlyincludeToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/onlyinclude.js?");

/***/ }),

/***/ "./src/parameter.js":
/*!**************************!*\
  !*** ./src/parameter.js ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst Parser = __webpack_require__(/*! .. */ \"./index.js\"), Token = __webpack_require__(/*! . */ \"./src/index.js\");\nclass ParameterToken extends Token {\n  constructor(key, value, config = Parser.getConfig(), accum = []) {\n    super(void 0, config, true, accum);\n    __publicField(this, \"type\", \"parameter\");\n    const AtomToken = __webpack_require__(/*! ./atom */ \"./src/atom/index.js\");\n    const keyToken = new AtomToken(typeof key === \"number\" ? void 0 : key, \"parameter-key\", config, accum), token = new Token(value, config, true, accum);\n    token.type = \"parameter-value\";\n    this.append(keyToken, token.setAttribute(\"stage\", 2));\n  }\n  get anon() {\n    return this.firstChild.childNodes.length === 0;\n  }\n  afterBuild() {\n    if (!this.anon) {\n      const TranscludeToken = __webpack_require__(/*! ./transclude */ \"./src/transclude.js\");\n      const name = String(this.firstChild).trim(), { parentNode } = this;\n      this.setAttribute(\"name\", name);\n      if (parentNode && parentNode instanceof TranscludeToken) {\n        parentNode.getArgs(name).add(this);\n      }\n    }\n    return this;\n  }\n  toString() {\n    return this.anon ? this.lastChild.toString() : super.toString(\"=\");\n  }\n  getGaps() {\n    return this.anon ? 0 : 1;\n  }\n  print() {\n    return super.print({ sep: this.anon ? \"\" : \"=\" });\n  }\n}\nmodule.exports = ParameterToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/parameter.js?");

/***/ }),

/***/ "./src/pre.js":
/*!********************!*\
  !*** ./src/pre.js ***!
  \********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst Parser = __webpack_require__(/*! .. */ \"./index.js\"), Token = __webpack_require__(/*! . */ \"./src/index.js\");\nclass PreToken extends Token {\n  constructor(wikitext, config = Parser.getConfig(), accum = []) {\n    super(wikitext, config, true, accum);\n    __publicField(this, \"type\", \"ext-inner\");\n    __publicField(this, \"name\", \"pre\");\n    this.setAttribute(\"stage\", Parser.MAX_STAGE - 1);\n  }\n  isPlain() {\n    return true;\n  }\n}\nmodule.exports = PreToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/pre.js?");

/***/ }),

/***/ "./src/syntax.js":
/*!***********************!*\
  !*** ./src/syntax.js ***!
  \***********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Parser = __webpack_require__(/*! .. */ \"./index.js\"), Token = __webpack_require__(/*! . */ \"./src/index.js\");\nclass SyntaxToken extends Token {\n  constructor(wikitext, type = \"plain\", config = Parser.getConfig(), accum = []) {\n    super(wikitext, config, true, accum);\n    this.type = type;\n  }\n}\nmodule.exports = SyntaxToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/syntax.js?");

/***/ }),

/***/ "./src/table/index.js":
/*!****************************!*\
  !*** ./src/table/index.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst { generateForChild } = __webpack_require__(/*! ../../util/lint */ \"./util/lint.js\"), TrToken = __webpack_require__(/*! ./tr */ \"./src/table/tr.js\"), SyntaxToken = __webpack_require__(/*! ../syntax */ \"./src/syntax.js\");\nclass TableToken extends TrToken {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"type\", \"table\");\n  }\n  get closed() {\n    return this.lastChild.type === \"table-syntax\";\n  }\n  lint(start = 0) {\n    const errors = super.lint(start);\n    if (!this.closed) {\n      errors.push(generateForChild(this.firstChild, this.getRootNode().posFromIndex(start), \"\\u672A\\u95ED\\u5408\\u7684\\u8868\\u683C\"));\n    }\n    return errors;\n  }\n  close(syntax = \"\\n|}\") {\n    const config = this.getAttribute(\"config\"), accum = this.getAttribute(\"accum\");\n    this.insertAt(new SyntaxToken(syntax, \"table-syntax\", config, accum));\n  }\n}\nmodule.exports = TableToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/table/index.js?");

/***/ }),

/***/ "./src/table/td.js":
/*!*************************!*\
  !*** ./src/table/td.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateWrapper = (obj, member, setter, getter) => ({\n  set _(value) {\n    __privateSet(obj, member, value, setter);\n  },\n  get _() {\n    return __privateGet(obj, member, getter);\n  }\n});\nvar _innerSyntax;\nconst Parser = __webpack_require__(/*! ../.. */ \"./index.js\"), Token = __webpack_require__(/*! .. */ \"./src/index.js\"), TrToken = __webpack_require__(/*! ./tr */ \"./src/table/tr.js\");\nclass TdToken extends TrToken {\n  constructor(syntax, inner, config = Parser.getConfig(), accum = []) {\n    let innerSyntax = inner == null ? void 0 : inner.match(/\\||\\0\\d+!\\x7F/u), attr = innerSyntax ? inner.slice(0, innerSyntax.index) : \"\";\n    if (/\\[\\[|-\\{/u.test(attr)) {\n      innerSyntax = null;\n      attr = \"\";\n    }\n    super(syntax, attr, config, accum);\n    __publicField(this, \"type\", \"td\");\n    __privateAdd(this, _innerSyntax, \"\");\n    if (innerSyntax) {\n      [__privateWrapper(this, _innerSyntax)._] = innerSyntax;\n    }\n    const innerToken = new Token(inner == null ? void 0 : inner.slice((innerSyntax == null ? void 0 : innerSyntax.index) + __privateGet(this, _innerSyntax).length), config, true, accum);\n    innerToken.type = \"td-inner\";\n    this.insertAt(innerToken.setAttribute(\"stage\", 4));\n  }\n  afterBuild() {\n    if (__privateGet(this, _innerSyntax).includes(\"\\0\")) {\n      __privateSet(this, _innerSyntax, this.getAttribute(\"buildFromStr\")(__privateGet(this, _innerSyntax)).map(String).join(\"\"));\n    }\n    return this;\n  }\n  toString() {\n    const { childNodes: [syntax, attr, inner] } = this;\n    return `${syntax.toString()}${attr.toString()}${__privateGet(this, _innerSyntax)}${inner.toString()}`;\n  }\n  getGaps(i = 0) {\n    i = i < 0 ? i + this.childNodes.length : i;\n    return i === 1 ? __privateGet(this, _innerSyntax).length : 0;\n  }\n  print() {\n    const { childNodes: [syntax, attr, inner] } = this;\n    return `<span class=\"wpb-td\">${syntax.print()}${attr.print()}${__privateGet(this, _innerSyntax)}${inner.print()}</span>`;\n  }\n}\n_innerSyntax = new WeakMap();\nmodule.exports = TdToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/table/td.js?");

/***/ }),

/***/ "./src/table/tr.js":
/*!*************************!*\
  !*** ./src/table/tr.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst { generateForChild } = __webpack_require__(/*! ../../util/lint */ \"./util/lint.js\"), Parser = __webpack_require__(/*! ../.. */ \"./index.js\"), Token = __webpack_require__(/*! .. */ \"./src/index.js\"), SyntaxToken = __webpack_require__(/*! ../syntax */ \"./src/syntax.js\");\nclass TrToken extends Token {\n  constructor(syntax, attr = \"\", config = Parser.getConfig(), accum = []) {\n    super(void 0, config, true, accum);\n    __publicField(this, \"type\", \"tr\");\n    const AttributeToken = __webpack_require__(/*! ../attribute */ \"./src/attribute.js\");\n    this.append(\n      new SyntaxToken(syntax, \"table-syntax\", config, accum),\n      new AttributeToken(attr, \"table-attr\", config, accum)\n    );\n  }\n  lint(start = 0) {\n    const errors = super.lint(start), inter = this.childNodes.find(({ type }) => type === \"table-inter\"), str = String(inter).trim();\n    if (inter && str && !/^<!--.*-->$/su.test(str)) {\n      const error = generateForChild(inter, this.getRootNode().posFromIndex(start), \"\\u5C06\\u88AB\\u79FB\\u51FA\\u8868\\u683C\\u7684\\u5185\\u5BB9\");\n      error.startLine++;\n      error.startCol = 0;\n      errors.push(error);\n    }\n    return errors;\n  }\n}\nmodule.exports = TrToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/table/tr.js?");

/***/ }),

/***/ "./src/tagPair/ext.js":
/*!****************************!*\
  !*** ./src/tagPair/ext.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst Parser = __webpack_require__(/*! ../.. */ \"./index.js\"), TagPairToken = __webpack_require__(/*! . */ \"./src/tagPair/index.js\");\nclass ExtToken extends TagPairToken {\n  constructor(name, attr = \"\", inner = \"\", closed = void 0, config = Parser.getConfig(), accum = []) {\n    attr = !attr || attr.trimStart() !== attr ? attr : ` ${attr}`;\n    const Token = __webpack_require__(/*! .. */ \"./src/index.js\"), AttributeToken = __webpack_require__(/*! ../attribute */ \"./src/attribute.js\");\n    const lcName = name.toLowerCase(), attrToken = new AttributeToken(attr, \"ext-attr\", config, accum), newConfig = JSON.parse(JSON.stringify(config)), ext = new Set(newConfig.ext);\n    let innerToken;\n    ext.delete(lcName);\n    newConfig.ext = [...ext];\n    switch (lcName) {\n      case \"tab\":\n        ext.delete(\"tabs\");\n        newConfig.ext = [...ext];\n      case \"indicator\":\n      case \"poem\":\n      case \"ref\":\n      case \"option\":\n      case \"combooption\":\n      case \"tabs\":\n      case \"poll\":\n        innerToken = new Token(inner, newConfig, true, accum);\n        break;\n      case \"gallery\": {\n        const GalleryToken = __webpack_require__(/*! ../gallery */ \"./src/gallery.js\");\n        innerToken = new GalleryToken(inner, newConfig, accum);\n        break;\n      }\n      case \"pre\": {\n        const PreToken = __webpack_require__(/*! ../pre */ \"./src/pre.js\");\n        innerToken = new PreToken(inner, newConfig, accum);\n        break;\n      }\n      case \"references\":\n      case \"choose\":\n      case \"combobox\": {\n        const NestedToken = __webpack_require__(/*! ../nested */ \"./src/nested/index.js\"), NestedExtToken = __webpack_require__(\"./src/nested sync recursive ^\\\\.\\\\/.*$\")(`./${lcName}`);\n        innerToken = new NestedExtToken(inner, newConfig, accum);\n        break;\n      }\n      case \"inputbox\": {\n        const InputboxToken = __webpack_require__(/*! ../inputbox */ \"./src/inputbox.js\");\n        innerToken = new InputboxToken(inner, newConfig, accum);\n        break;\n      }\n      default: {\n        const NowikiToken = __webpack_require__(/*! ../nowiki */ \"./src/nowiki/index.js\");\n        innerToken = new NowikiToken(inner, config);\n      }\n    }\n    innerToken.setAttribute(\"name\", lcName).type = \"ext-inner\";\n    super(name, attrToken, innerToken, closed, config, accum);\n    __publicField(this, \"type\", \"ext\");\n    __publicField(this, \"closed\", true);\n  }\n}\nmodule.exports = ExtToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/tagPair/ext.js?");

/***/ }),

/***/ "./src/tagPair/include.js":
/*!********************************!*\
  !*** ./src/tagPair/include.js ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst { generateForSelf } = __webpack_require__(/*! ../../util/lint */ \"./util/lint.js\"), hidden = __webpack_require__(/*! ../../mixin/hidden */ \"./mixin/hidden.js\"), Parser = __webpack_require__(/*! ../.. */ \"./index.js\"), TagPairToken = __webpack_require__(/*! . */ \"./src/tagPair/index.js\");\nclass IncludeToken extends hidden(TagPairToken) {\n  constructor(name, attr = \"\", inner = void 0, closed = void 0, config = Parser.getConfig(), accum = []) {\n    super(name, attr, inner != null ? inner : \"\", inner === void 0 ? closed : closed != null ? closed : \"\", config, accum);\n    __publicField(this, \"type\", \"include\");\n  }\n  lint(start = 0) {\n    return this.closed ? [] : [generateForSelf(this, this.getRootNode().posFromIndex(start), \"\\u672A\\u95ED\\u5408\\u7684\\u6807\\u7B7E\")];\n  }\n}\nmodule.exports = IncludeToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/tagPair/include.js?");

/***/ }),

/***/ "./src/tagPair/index.js":
/*!******************************!*\
  !*** ./src/tagPair/index.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _selfClosing, _closed, _tags;\nconst Parser = __webpack_require__(/*! ../.. */ \"./index.js\"), Token = __webpack_require__(/*! .. */ \"./src/index.js\");\nclass TagPairToken extends Token {\n  constructor(name, attr, inner, closed, config = Parser.getConfig(), accum = []) {\n    super(void 0, config, true);\n    __privateAdd(this, _selfClosing, void 0);\n    __privateAdd(this, _closed, void 0);\n    __privateAdd(this, _tags, void 0);\n    __privateSet(this, _tags, [name, closed || name]);\n    __privateSet(this, _selfClosing, closed === void 0);\n    __privateSet(this, _closed, closed !== \"\");\n    this.append(attr, inner);\n    let index = accum.indexOf(attr);\n    if (index === -1) {\n      index = accum.indexOf(inner);\n    }\n    if (index === -1) {\n      index = Infinity;\n    }\n    accum.splice(index, 0, this);\n  }\n  get closed() {\n    return __privateGet(this, _closed);\n  }\n  toString() {\n    const { firstChild, lastChild } = this, [opening, closing] = __privateGet(this, _tags);\n    return __privateGet(this, _selfClosing) ? `<${opening}${String(firstChild)}/>` : `<${opening}${String(firstChild)}>${String(lastChild)}${__privateGet(this, _closed) ? `</${closing}>` : \"\"}`;\n  }\n  getPadding() {\n    return __privateGet(this, _tags)[0].length + 1;\n  }\n  getGaps() {\n    return 1;\n  }\n  print() {\n    const [opening, closing] = __privateGet(this, _tags);\n    return super.print(__privateGet(this, _selfClosing) ? { pre: `&lt;${opening}`, post: \"/&gt;\" } : { pre: `&lt;${opening}`, sep: \"&gt;\", post: __privateGet(this, _closed) ? `&lt;/${closing}&gt;` : \"\" });\n  }\n}\n_selfClosing = new WeakMap();\n_closed = new WeakMap();\n_tags = new WeakMap();\nmodule.exports = TagPairToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/tagPair/index.js?");

/***/ }),

/***/ "./src/transclude.js":
/*!***************************!*\
  !*** ./src/transclude.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\nvar _args, _handleAnonArgChange, handleAnonArgChange_fn;\nconst { removeComment, print } = __webpack_require__(/*! ../util/string */ \"./util/string.js\"), { generateForChild } = __webpack_require__(/*! ../util/lint */ \"./util/lint.js\"), Parser = __webpack_require__(/*! .. */ \"./index.js\"), Token = __webpack_require__(/*! . */ \"./src/index.js\"), ParameterToken = __webpack_require__(/*! ./parameter */ \"./src/parameter.js\");\nclass TranscludeToken extends Token {\n  constructor(title, parts, config = Parser.getConfig(), accum = []) {\n    super(void 0, config, true, accum);\n    __privateAdd(this, _handleAnonArgChange);\n    __publicField(this, \"type\", \"template\");\n    __publicField(this, \"modifier\", \"\");\n    __privateAdd(this, _args, {});\n    const AtomToken = __webpack_require__(/*! ./atom */ \"./src/atom/index.js\"), SyntaxToken = __webpack_require__(/*! ./syntax */ \"./src/syntax.js\");\n    const { parserFunction: [insensitive, sensitive, raw] } = config;\n    if (title.includes(\":\")) {\n      const [modifier, ...arg] = title.split(\":\");\n      if (this.setModifier(modifier)) {\n        title = arg.join(\":\");\n      }\n    }\n    if (title.includes(\":\") || parts.length === 0 && !raw.includes(this.modifier.toLowerCase())) {\n      const [magicWord, ...arg] = title.split(\":\"), name = removeComment(magicWord), isSensitive = sensitive.includes(name);\n      if (isSensitive || insensitive.includes(name.toLowerCase())) {\n        this.setAttribute(\"name\", name.toLowerCase().replace(/^#/u, \"\")).type = \"magic-word\";\n        const token = new SyntaxToken(magicWord, \"magic-word-name\", config, accum);\n        this.insertAt(token);\n        if (arg.length > 0) {\n          parts.unshift([arg.join(\":\")]);\n        }\n        if (this.name === \"invoke\") {\n          for (let i2 = 0; i2 < 2; i2++) {\n            const part = parts.shift();\n            if (!part) {\n              break;\n            }\n            const invoke = new AtomToken(part.join(\"=\"), `invoke-${i2 ? \"function\" : \"module\"}`, config, accum);\n            this.insertAt(invoke);\n          }\n        }\n      }\n    }\n    if (this.type === \"template\") {\n      const [name] = removeComment(title).split(\"#\");\n      if (/\\0\\d+[eh!+-]\\x7F|[<>[\\]{}]/u.test(name)) {\n        accum.pop();\n        throw new SyntaxError(`\\u975E\\u6CD5\\u7684\\u6A21\\u677F\\u540D\\u79F0\\uFF1A${name}`);\n      }\n      const token = new AtomToken(title, \"template-name\", config, accum);\n      this.insertAt(token);\n    }\n    const templateLike = this.isTemplate();\n    let i = 1;\n    for (const part of parts) {\n      if (!templateLike) {\n        part[0] = part.join(\"=\");\n        part.length = 1;\n      }\n      if (part.length === 1) {\n        part.unshift(i);\n        i++;\n      }\n      this.insertAt(new ParameterToken(...part, config, accum));\n    }\n  }\n  setModifier(modifier = \"\") {\n    const { parserFunction: [, , raw, subst] } = this.getAttribute(\"config\"), lcModifier = modifier.trim().toLowerCase(), isRaw = raw.includes(lcModifier), isSubst = subst.includes(lcModifier);\n    if (isRaw || isSubst || modifier === \"\") {\n      this.setAttribute(\"modifier\", modifier);\n      return Boolean(modifier);\n    }\n    return false;\n  }\n  toString() {\n    const { childNodes, firstChild, modifier } = this;\n    return `{{${modifier}${modifier && \":\"}${this.type === \"magic-word\" ? `${String(firstChild)}${childNodes.length > 1 ? \":\" : \"\"}${childNodes.slice(1).map(String).join(\"|\")}` : super.toString(\"|\")}}}`;\n  }\n  getPadding() {\n    return this.modifier ? this.modifier.length + 3 : 2;\n  }\n  getGaps() {\n    return 1;\n  }\n  print() {\n    const { childNodes, firstChild, modifier } = this;\n    return `<span class=\"wpb-${this.type}\">{{${modifier}${modifier && \":\"}${this.type === \"magic-word\" ? `${firstChild.print()}${childNodes.length > 1 ? \":\" : \"\"}${print(childNodes.slice(1), { sep: \"|\" })}` : print(childNodes, { sep: \"|\" })}}}</span>`;\n  }\n  lint(start = 0) {\n    const errors = super.lint(start);\n    if (!this.isTemplate()) {\n      return errors;\n    }\n    const duplicatedArgs = this.getDuplicatedArgs();\n    if (duplicatedArgs.length > 0) {\n      const rect = this.getRootNode().posFromIndex(start);\n      errors.push(...duplicatedArgs.flatMap(([, args]) => [...args]).map(\n        (arg) => generateForChild(arg, rect, \"\\u91CD\\u590D\\u53C2\\u6570\")\n      ));\n    }\n    return errors;\n  }\n  isTemplate() {\n    return this.type === \"template\" || this.type === \"magic-word\" && this.name === \"invoke\";\n  }\n  insertAt(token, i = this.childNodes.length) {\n    super.insertAt(token, i);\n    if (token.anon) {\n      __privateMethod(this, _handleAnonArgChange, handleAnonArgChange_fn).call(this, token);\n    } else if (token.name) {\n      this.getArgs(token.name).add(token);\n    }\n    return token;\n  }\n  getAllArgs() {\n    return this.childNodes.filter((child) => child instanceof ParameterToken);\n  }\n  getAnonArgs() {\n    return this.getAllArgs().filter(({ anon }) => anon);\n  }\n  getArgs(key) {\n    const keyStr = String(key).trim();\n    let args;\n    if (Object.prototype.hasOwnProperty.call(__privateGet(this, _args), keyStr)) {\n      args = __privateGet(this, _args)[keyStr];\n    } else {\n      args = new Set(this.getAllArgs().filter(({ name }) => keyStr === name));\n      __privateGet(this, _args)[keyStr] = args;\n    }\n    return args;\n  }\n  getDuplicatedArgs() {\n    return this.isTemplate() ? Object.entries(__privateGet(this, _args)).filter(([, { size }]) => size > 1).map(([key, args]) => [key, new Set(args)]) : [];\n  }\n}\n_args = new WeakMap();\n_handleAnonArgChange = new WeakSet();\nhandleAnonArgChange_fn = function(addedToken) {\n  const args = this.getAnonArgs(), j = args.indexOf(addedToken), newName = String(j + 1);\n  this.getArgs(newName).add(addedToken.setAttribute(\"name\", newName));\n};\nmodule.exports = TranscludeToken;\n\n\n//# sourceURL=webpack://wikiparser-node/./src/transclude.js?");

/***/ }),

/***/ "./util/lint.js":
/*!**********************!*\
  !*** ./util/lint.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Token = __webpack_require__(/*! ../src */ \"./src/index.js\");\nconst generateForChild = (child, boundingRect, message, severity = \"error\") => {\n  const { style: { top: offsetTop, left: offsetLeft, height, width } } = child, { top, left } = boundingRect, startLine = top + offsetTop, endLine = startLine + height - 1, startCol = offsetTop ? offsetLeft : left + offsetLeft, endCol = height > 1 ? width : startCol + width;\n  return { message, severity, startLine, endLine, startCol, endCol };\n};\nconst generateForSelf = (token, boundingRect, message, severity = \"error\") => ({\n  message,\n  severity,\n  startLine: boundingRect.top,\n  endLine: boundingRect.top + token.offsetHeight - 1,\n  startCol: boundingRect.left,\n  endCol: token.offsetHeight > 1 ? token.offsetWidth : boundingRect.left + token.offsetWidth\n});\nmodule.exports = { generateForChild, generateForSelf };\n\n\n//# sourceURL=webpack://wikiparser-node/./util/lint.js?");

/***/ }),

/***/ "./util/string.js":
/*!************************!*\
  !*** ./util/string.js ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst removeComment = (str) => str.replaceAll(/\\0\\d+c\\x7F/gu, \"\");\nconst print = (childNodes, opt = {}) => {\n  const AstText = __webpack_require__(/*! ../lib/text */ \"./lib/text.js\"), AstElement = __webpack_require__(/*! ../lib/element */ \"./lib/element.js\");\n  const { pre = \"\", post = \"\", sep = \"\" } = opt, entities = { \"&\": \"amp\", \"<\": \"lt\", \">\": \"gt\" };\n  return `${pre}${childNodes.map(\n    (child) => child instanceof AstElement ? child.print() : String(child).replaceAll(/[&<>]/gu, (p) => `&${entities[p]};`)\n  ).join(sep)}${post}`;\n};\nconst escapeRegExp = (str) => str.replaceAll(/[\\\\{}()|.?*+^$[\\]]/gu, \"\\\\$&\");\nconst explode = (start, end, separator, str) => {\n  if (str === void 0) {\n    return [];\n  }\n  const regex = new RegExp(`${[start, end, separator].map(escapeRegExp).join(\"|\")}`, \"gu\"), exploded = [];\n  let mt = regex.exec(str), depth = 0, lastIndex = 0;\n  while (mt) {\n    const { 0: match, index } = mt;\n    if (match !== separator) {\n      depth += match === start ? 1 : -1;\n    } else if (depth === 0) {\n      exploded.push(str.slice(lastIndex, index));\n      ({ lastIndex } = regex);\n    }\n    mt = regex.exec(str);\n  }\n  exploded.push(str.slice(lastIndex));\n  return exploded;\n};\nconst extUrlChar = '(?:\\\\[[\\\\da-f:.]+\\\\]|[^[\\\\]<>\"\\\\0-\\\\x1F\\\\x7F\\\\p{Zs}\\\\uFFFD])(?:[^[\\\\]<>\"\\\\0-\\\\x1F\\\\x7F\\\\p{Zs}\\\\uFFFD]|\\\\0\\\\d+c\\\\x7F)*';\nmodule.exports = { removeComment, print, escapeRegExp, explode, extUrlChar };\n\n\n//# sourceURL=webpack://wikiparser-node/./util/string.js?");

/***/ }),

/***/ "./src/nested sync recursive ^\\.\\/.*$":
/*!***********************************!*\
  !*** ./src/nested/ sync ^\.\/.*$ ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var map = {\n\t\"./\": \"./src/nested/index.js\",\n\t\"./choose\": \"./src/nested/choose.js\",\n\t\"./choose.js\": \"./src/nested/choose.js\",\n\t\"./combobox\": \"./src/nested/combobox.js\",\n\t\"./combobox.js\": \"./src/nested/combobox.js\",\n\t\"./index\": \"./src/nested/index.js\",\n\t\"./index.js\": \"./src/nested/index.js\",\n\t\"./references\": \"./src/nested/references.js\",\n\t\"./references.js\": \"./src/nested/references.js\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/nested sync recursive ^\\\\.\\\\/.*$\";\n\n//# sourceURL=webpack://wikiparser-node/./src/nested/_sync_^\\.\\/.*$?");

/***/ }),

/***/ "./config/minimum.json":
/*!*****************************!*\
  !*** ./config/minimum.json ***!
  \*****************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"ext\":[\"nowiki\",\"pre\",\"gallery\",\"indicator\"],\"html\":[[\"b\",\"bdi\",\"del\",\"i\",\"ins\",\"u\",\"font\",\"big\",\"small\",\"sub\",\"sup\",\"h1\",\"h2\",\"h3\",\"h4\",\"h5\",\"h6\",\"cite\",\"code\",\"em\",\"s\",\"strike\",\"strong\",\"tt\",\"var\",\"div\",\"center\",\"blockquote\",\"ol\",\"ul\",\"dl\",\"table\",\"caption\",\"pre\",\"ruby\",\"rb\",\"rp\",\"rt\",\"rtc\",\"p\",\"span\",\"abbr\",\"dfn\",\"kbd\",\"samp\",\"data\",\"time\",\"mark\",\"tr\",\"td\",\"th\",\"q\",\"bdo\"],[\"li\",\"dt\",\"dd\"],[\"br\",\"wbr\",\"hr\",\"meta\",\"link\",\"img\"]],\"namespaces\":{\"0\":\"\",\"6\":\"File\",\"14\":\"Category\"},\"nsid\":{\"\":0,\"file\":6,\"image\":6,\"图像\":6,\"圖像\":6,\"文件\":6,\"档案\":6,\"檔案\":6,\"category\":14,\"分类\":14,\"分類\":14},\"parserFunction\":[[\"名称空间\",\"ns\",\"名称空间e\",\"nse\",\"url编码\",\"urlencode\",\"小写首字\",\"lcfirst\",\"大写首字\",\"ucfirst\",\"小写\",\"lc\",\"大写\",\"uc\",\"本地url\",\"localurl\",\"本地urle\",\"localurle\",\"完整url\",\"fullurl\",\"完整url等同\",\"fullurle\",\"规范url\",\"canonicalurl\",\"规范url等同\",\"canonicalurle\",\"格式化数字\",\"formatnum\",\"语法\",\"grammar\",\"性别\",\"gender\",\"复数\",\"plural\",\"bidi\",\"#语言\",\"#language\",\"左填充\",\"padleft\",\"右填充\",\"padright\",\"锚编码\",\"anchorencode\",\"文件路径\",\"filepath\",\"页面id\",\"pageid\",\"界面\",\"int\",\"#特殊\",\"#special\",\"#特殊等同\",\"#speciale\",\"#标记\",\"#tag\",\"#格式化日期\",\"#日期格式化\",\"#formatdate\",\"#dateformat\",\"#invoke\",\"#while\",\"#dowhile\",\"#loop\",\"#forargs\",\"#fornumargs\",\"#非空式\",\"#若\",\"#如果\",\"#if\",\"#相同式\",\"#匹配式\",\"#若相等\",\"#如果相等\",\"#ifeq\",\"#多选式\",\"#多条件式\",\"#双射式\",\"#开关\",\"#转换\",\"#switch\",\"#存在式\",\"#若有\",\"#如有\",\"#ifexist\",\"#若表达式\",\"#ifexpr\",\"#错误式\",\"#如果错误\",\"#iferror\",\"#时间\",\"#time\",\"#时间l\",\"#timel\",\"#计算式\",\"#表达式\",\"#expr\",\"#rel2abs\",\"#标题组成部分\",\"#titleparts\",\"#categorytree\",\"#url解码\",\"#urldecode\",\"#choose\",\"#调用\",\"#var\",\"#varexists\",\"#var_final\",\"#vardefine\",\"#vardefineecho\",\"#小工具\",\"#widget\",\"条目路径\",\"articlepath\",\"服务器\",\"server\",\"服务器名\",\"servername\",\"脚本路径\",\"scriptpath\",\"样式路径\",\"stylepath\",\"msgnw\",\"#related\",\"#cscore\"],[],[\"msg\",\"原始\",\"raw\"],[\"替代\",\"subst\",\"安全替代\",\"safesubst\"]],\"doubleUnderscore\":[[],[]],\"protocol\":\"bitcoin:|ftp://|ftps://|geo:|git://|gopher://|http://|https://|irc://|ircs://|magnet:|mailto:|mms://|news:|nntp://|redis://|sftp://|sip:|sips:|sms:|ssh://|svn://|tel:|telnet://|urn:|worldwind://|xmpp:\",\"interwiki\":[],\"img\":{\"thumbnail\":\"thumbnail\",\"thumb\":\"thumbnail\",\"缩略图\":\"thumbnail\",\"thumbnail=$1\":\"manualthumb\",\"thumb=$1\":\"manualthumb\",\"缩略图=$1\":\"manualthumb\",\"left\":\"left\",\"左\":\"left\",\"right\":\"right\",\"右\":\"right\",\"none\":\"none\",\"无\":\"none\",\"$1px\":\"width\",\"$1像素\":\"width\",\"center\":\"center\",\"centre\":\"center\",\"居中\":\"center\",\"framed\":\"framed\",\"enframed\":\"framed\",\"frame\":\"framed\",\"有框\":\"framed\",\"frameless\":\"frameless\",\"无框\":\"frameless\",\"upright\":\"upright\",\"右上\":\"upright\",\"upright=$1\":\"manual-upright\",\"upright $1\":\"manual-upright\",\"右上=$1\":\"manual-upright\",\"右上$1\":\"manual-upright\",\"border\":\"border\",\"边框\":\"border\",\"alt=$1\":\"alt\",\"替代=$1\":\"alt\",\"替代文本=$1\":\"alt\",\"class=$1\":\"class\",\"类=$1\":\"class\",\"link=$1\":\"link\",\"链接=$1\":\"link\",\"baseline\":\"baseline\",\"基线\":\"baseline\",\"sub\":\"sub\",\"子\":\"sub\",\"super\":\"super\",\"sup\":\"super\",\"超\":\"super\",\"top\":\"top\",\"顶部\":\"top\",\"text-top\":\"text-top\",\"文字顶部\":\"text-top\",\"middle\":\"middle\",\"中间\":\"middle\",\"bottom\":\"bottom\",\"底部\":\"bottom\",\"text-bottom\":\"text-bottom\",\"文字底部\":\"text-bottom\",\"lang=$1\":\"lang\",\"语言=$1\":\"lang\",\"page=$1\":\"page\",\"page $1\":\"page\",\"页数=$1\":\"page\",\"$1页\":\"page\"},\"variants\":[\"zh\",\"zh-hans\",\"zh-hant\",\"zh-cn\",\"zh-tw\",\"zh-hk\",\"zh-sg\",\"zh-my\",\"zh-mo\"]}');\n\n//# sourceURL=webpack://wikiparser-node/./config/minimum.json?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ })()
;